{"pages":[],"posts":[{"title":"C语言实现五子棋游戏","text":"C语言课设项目 基于C语言和EasyX图形库实现的五子棋小游戏 AI算法采用极大极小值搜索中应用Alpha-Beta剪枝 实现人机对战等功能 引言博弈算法 零和博弈，又称零和游戏或零和赛局，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有收入，其他方必有所失。 这里所提到的博弈算法适用于有完备信息的，确定性的，轮流行动的两个游戏者的零和游戏，像大多数的棋类游戏，如五子棋，象棋，围棋都满足这些条件，可以通过这套算法实现。 五子棋在今日已经被证明了是一种“不公平”的游戏，黑棋先手绝对占优，并且有先手必胜的套路。因此，五子棋发展出了各种限制黑棋的规则（如三三禁手），此类五子棋被称为“连珠”。 本文实现的五子棋为无禁手五子棋，AI算法较为简单，棋力水平达到业余水平。 界面设计此项目使用vs2019为开发工具，借助了EasyX图形库，实现较为简单的UI 程序基本结构123456789101112131415int main(){ while (1) { if (startGame() == 1) { //startGame函数为开始界面初始化 int win = game1(); //game1，game2函数分别实现人机和玩家pk gameOver1(win); } else { int win = game2(); gameOver2(win); } } return 0;} 开始页面其中涉及音乐和图片素材调用，素材文件路径可改变 涉及的EasyX图形库函数，可在EasyX文档中查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int startGame() { initgraph(600, 600); IMAGE im_start; loadimage(&amp;im_start, _T(&quot;D:\\\\素材\\\\start.jpg&quot;)); //开始界面图片 putimage(0, 0, &amp;im_start); setlinecolor(BLACK); //绘制选择按钮 setfillcolor(RGB(254, 220, 130)); fillrectangle(50, 490, 170, 545); fillrectangle(240, 490, 360, 545); fillrectangle(430, 490, 550, 545); setbkmode(TRANSPARENT); settextcolor(BLACK); LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(25, 0, _T(&quot;黑体&quot;)); outtextxy(60, 510, _T(&quot;人机对战&quot;)); outtextxy(250, 510, _T(&quot;双人游戏&quot;)); outtextxy(440, 510, _T(&quot;退出游戏&quot;)); settextstyle(&amp;nowstyle); mciSendString(_T(&quot;close stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;open D:\\\\素材\\\\background.mp3 alias bgmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play bgmusic repeat&quot;), NULL, 0, NULL); int gamemode = 0; init_tuple6type(); //调用初始化棋形函数，具体在AI算法中实现 while (1) { MOUSEMSG mouse = GetMouseMsg(); // if (mouse.x &gt;= 50 &amp;&amp; mouse.x &lt;= 170 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 1; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 240 &amp;&amp; mouse.x &lt;= 360 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 2; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 430 &amp;&amp; mouse.x &lt;= 550 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic wait&quot;), NULL, 0, NULL); exit(0); } } mciSendString(_T(&quot;close bgmusic&quot;), NULL, 0, NULL); return gamemode;} 棋盘数据 棋盘数据由结构体数组储存 12345678typedef struct node { //棋盘每个节点的数据储存 int x; //左上顶点坐标 int y; int model; //格子边框样式 int value; //是否落子（0代表无, 黑棋1, 白棋2） bool isnew; //是否显示选择框 COLORREF color; //格子颜色}NODE; 全局变量 12NODE map[15][15];COLORREF COLOR = RGB(255, 183, 111); 棋盘绘制 初始化棋盘数组中的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void initNode(){ for (int i = 75, k = 0; i &lt;= 495; i = i + 30) { for (int j = 75, g = 0; j &lt;= 495; j = j + 30) { map[k][g].x = j; map[k][g].y = i; map[k][g].value = 0; map[k][g].isnew = false; map[k][g].color = COLOR; if (k == 0 &amp;&amp; g == 0) //根据格子位置判断格子边框 { map[k][g].model = 8; } else if (k == 0 &amp;&amp; g == 14) { map[k][g].model = 7; } else if (k == 14 &amp;&amp; g == 14) { map[k][g].model = 6; } else if (k == 14 &amp;&amp; g == 0) { map[k][g].model = 5; } else if (k == 0) { map[k][g].model = 3; } else if (k == 14) { map[k][g].model = 4; } else if (g == 0) { map[k][g].model = 1; } else if (g == 14) { map[k][g].model = 2; } else if ((k == 3 &amp;&amp; g == 3) || (k == 3 &amp;&amp; g == 11) || (k == 11 &amp;&amp; g == 3) || (k == 11 &amp;&amp; g == 11) || (k == 7 &amp;&amp; g == 7)) { map[k][g].model = 9; } else { map[k][g].model = 0; } g++; } k++; } } 下棋时，棋盘会随着鼠标移动显示选择框，避免不断绘制整个棋盘导致的闪屏，于是将棋盘绘制设计为每个格子逐个绘制，在更新选择框时仅重新绘制当前位置的图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138void drawNode(NODE* node){ int x = node-&gt;x; //获得当前节点数据 int y = node-&gt;y; int model = node-&gt;model; int value = node-&gt;value; int isnew = node-&gt;isnew; COLORREF color = node-&gt;color; setfillcolor(color); solidrectangle(x, y, x + 30, y + 30); //绘制边框 setlinecolor(BLACK); switch (model) { case 0: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); break; // * // * * * // * case 3: setlinestyle(PS_SOLID, 2); line(x + 15, y + 15, x + 15, y + 30); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * * * // * // * case 4: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * // * // * * * case 1: setlinestyle(PS_SOLID, 2); line(x + 14, y + 15, x + 30, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 2: setlinestyle(PS_SOLID, 2); line(x - 1, y + 15, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 7: setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 15, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 6: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x - 1, y + 15, x + 15, y + 15); break; // * // * // * * * case 5: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x + 15, y + 15, x + 30, y + 15); break; // * // * // * * * case 8: setlinestyle(PS_SOLID, 3); line(x + 15, y + 15, x + 30, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 9: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); setfillcolor(BLACK); setlinestyle(PS_SOLID, 2); fillcircle(x + 15, y + 15, 4); break; // * // * O * // * } //绘制选择框 if (isnew) { setlinestyle(PS_SOLID, 2); setlinecolor(LIGHTGRAY); line(x + 1, y + 2, x + 8, y + 2); line(x + 2, y + 1, x + 2, y + 8); line(x + 29, y + 2, x + 22, y + 2); line(x + 29, y + 1, x + 29, y + 8); line(x + 2, y + 29, x + 8, y + 29); line(x + 2, y + 22, x + 2, y + 29); line(x + 29, y + 29, x + 22, y + 29); line(x + 29, y + 22, x + 29, y + 29); } //绘制棋子 switch (value) { case 1: setfillcolor(BLACK); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; case 2: setfillcolor(WHITE); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; }} 绘制整个棋盘函数，不断调用绘制格子函数 12345678910111213141516171819202122232425262728293031void drawBoard(){ //更新每一个节点 for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { drawNode(&amp;map[i][j]); if (map[i][j].isnew == true) { map[i][j].isnew = false; // 把上一个下棋位置的选择框清除 } } } // 绘制坐标 TCHAR strnum[19][3] = { _T(&quot;1&quot;),_T(&quot;2&quot;) ,_T(&quot;3&quot;) ,_T(&quot;4&quot;),_T(&quot;5&quot;) ,_T(&quot;6&quot;) ,_T(&quot;7&quot;),_T(&quot;8&quot;),_T(&quot;9&quot;),_T(&quot;10&quot;), _T(&quot;11&quot;),_T(&quot;12&quot;) ,_T(&quot;13&quot;) ,_T(&quot;14&quot;),_T(&quot;15&quot;) }; TCHAR strabc[19][3] = { _T(&quot;A&quot;),_T(&quot;B&quot;) ,_T(&quot;C&quot;) ,_T(&quot;D&quot;),_T(&quot;E&quot;) ,_T(&quot;F&quot;) ,_T(&quot;G&quot;),_T(&quot;H&quot;),_T(&quot;I&quot;),_T(&quot;J&quot;), _T(&quot;K&quot;),_T(&quot;L&quot;) ,_T(&quot;M&quot;) ,_T(&quot;N&quot;),_T(&quot;O&quot;) }; LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(0, 0, NULL); settextcolor(BLACK); int number = 0; for (int i = 0; i &lt; 15; i++) { outtextxy(85 + number, 60, strnum[i]); outtextxy(60, 85 + number, strabc[i]); number += 30; } } 游戏函数 game1为实现人机对战的函数，其中关于AI算法函数稍后实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int game1() { //人机对战实现 Sleep(500); setbkcolor(COLOR); cleardevice(); initNode(); drawBoard(); settextstyle(20, 10, 0, 0, 0, 1000, false, false, false); settextcolor(BLACK); settextstyle(25, 0, NULL); outtextxy(90, 530, _T(&quot;玩家执黑先行&quot;)); int whoplay = 0; int oldi = 0; //更新鼠标位置所储存的坐标 int oldj = 0; while (1) { if (whoplay == 0) { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); MOUSEMSG mouse = GetMouseMsg(); if (mouse.x &gt;= 75 &amp;&amp; mouse.y &gt;= 75 &amp;&amp; mouse.x &lt;= 525 &amp;&amp; mouse.y &lt;= 525) { //判断鼠标所处节点 int j = (mouse.x - 75) / 30; int i = (mouse.y - 75) / 30; //判断是否是空位置 if (map[i][j].value == 0) { // 如果按下了 if (mouse.mkLButton) { map[i][j].value = C_BLACK; // 下棋 map[i][j].isnew = true; //更新选择框 whoplay = 1; //轮到下一个 drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { //判断是否获胜 return win; } oldi = 0; oldj = 0; continue; } // 更新节点 map[oldi][oldj].isnew = false; drawNode(&amp;map[oldi][oldj]); map[i][j].isnew = true; drawNode(&amp;map[i][j]); oldi = i; oldj = j; } } } else { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); int board[15][15]; mapToBoard(map, board); //AI下棋 analyse(board, 4, -INT_MAX, INT_MAX); //AI算法实现函数，应用极大极小值搜索 map[decision.best.x][decision.best.y].value = C_WHITE; map[decision.best.x][decision.best.y].isnew = true; whoplay = 0; drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { return win; } oldi = 0; oldj = 0; } }} 胜负判断 每次落子后调用胜负判断函数，若有一方胜出则结束游戏 123456789101112131415161718192021222324252627282930313233343536373839404142int winner(){ int iswin = 0; int dx[4] = { 1, 0, 1, 1 }; //向四种方向搜索棋盘 int dy[4] = { 0, 1, 1, -1 }; bool isfull = true; for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { if (map[i][j].value != 0) { int nowcolor = map[i][j].value; int length[4] = { 0, 0, 0, 0 }; for (int k = 0; k &lt; 4; k++) { int nowi = i; int nowj = j; while (map[nowi][nowj].value == nowcolor &amp;&amp; nowi &gt;= 0 &amp;&amp; nowi &lt;= 14 &amp;&amp; nowj &gt;= 0 &amp;&amp; nowj &lt;= 14) { length[k]++; nowi += dx[k]; nowj += dy[k]; } } for (int k = 0; k &lt; 4; k++) { if (length[k] &gt;= 5) { if (nowcolor == C_BLACK) { iswin = 1; } else { iswin = 2; } } } } else { isfull = false; } } } if (isfull) { iswin = 3; } return iswin;} 五子棋界面设计差不多已经完成，AI下棋的算法在下一篇 C语言实现五子棋游游戏(AI算法实现)","link":"/2021/07/16/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F/"},{"title":"LeetCode 611. 有效三角形的个数","text":"给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例1： 1234567输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3 解题思路1.暴力​ 这道题要求枚举符合条件的三元组，最简单的方法是通过三层循环直接枚举所有的组合，对三边都进行 a+b&lt;c &amp;&amp; a+c&lt;b &amp;&amp; b+c&lt;a 的判断，累加求出个数。 2.排序+二分​ 首先我们对数组进行排序，对于已排序数组，即三元组a &lt; b &lt; c，当且仅当 a + b &gt; c时符合条件，因此我们可以通过两层循环固定a,b，对于c在有序区间中找到小于a+b的最大值，则(b,c]中的元素个数即为当前a,b对应的解个数，累加即可。 ​ 时间复杂度为 $n^2log(n)$ 12345678910111213141516171819202122232425class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; int res = 0; int left, right, mid; for(int i = 0; i &lt; n - 2; i++){ for(int j = i + 1; j &lt; n - 1; j++){ left = j + 1; right = n - 1; while(left &lt; right){ mid = (left + right + 1) / 2; if(nums[mid] &gt;= nums[i] + nums[j]){ right = mid - 1; }else{ left = mid; } } if(nums[left] &lt; nums[i] + nums[j]) res += left - j; } } return res; }} 3.排序+双指针​ 依然首先对数组排序，我们考虑a + b &gt; c的条件，我们可以先固定最长边c，通过双指针来寻找a,b。一个关键点在于反向遍历c，每一个c对应的left和right指针，left=0，right=k-1。​ 如果nums[left] + nums[right] &gt; c,则[left, right]区间的所有数符合条件，right左移；​ 如果nums[left] + nums[right] &lt;= c,则left右移，直到大于c。​ 最后left于right碰撞，即已经找完当前c对应的所有解。 ​ 时间复杂度为 $n^2$ 1234567891011121314151617181920class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; int res = 0; for(int i = n-1; i&gt;=2; i--){ int right = i-1; int left = 0; while(left &lt; right){ if(nums[left] + nums[right] &gt; nums[i]){ res += right - left; right--; }else{ left++; } } } return res; }}","link":"/2021/12/29/LeetCode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"LeetCode7-53","text":"LeetCode07 整数反转 LeetCode53 最大子序和 leetcode7 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 1234567891011121314class Solution {public: int reverse(int x) { int result = 0; while(x != 0){ if(result &gt; INT_MAX / 10 || result &lt; INT_MIN / 10) return 0; int a = x % 10; x /= 10; result = result * 10 + a; } return result; } }; 这道题的算法思想为通过数学的方法，模拟数字的弹出和推入，关键点在于溢出的检测。 2^31-1=2147483647 -2^31=-2147483648 我们要保证返回的result不会溢出，就要在数字推入result前检测，方法为 1if(result &gt; INT_MAX / 10 || result &lt; INT_MIN / 10) 不能使用result * 10 &lt; INT_MAX. 这条语句同时也保证了推入数字a时也不会溢出，因为若要溢出，原数据x为10位数并且也小于INT_MAX，则最后推入的数字一定小于等于2，不会大于7而导致溢出，小于零时同理。 复杂度分析 时间复杂度：O(log |x|)。翻转的次数即 x十进制的位数 leetcode53 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 1234567891011class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int pre = 0, maxAns = nums[0]; for (int i = 0; i &lt; nums.size(); i++) { pre = max(pre + nums[i], nums[i]); maxAns = max(maxAns, pre); } return maxAns; }}; 动态规划 我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的…但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的 为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」 定义状态（定义子问题）dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。 状态转移方程$$dp[i]=\\begin{cases}dp[i-1]+nums[i],dp[i-1]&gt;0\\nums[i],dp[i-1]\\le0\\end{cases}$$ 还可以写成这样 $dp[i] = max{dp[i-1]+nums[i],,,,nums[i]}$ 输出把所有的 dp[0]、dp[1]、……、dp[n - 1] 都看一遍，取最大值 优化空间dp[i] 的值只与dp[i-1]有关，可以只使用一个变量来维护dp[i-1], 空间复杂度优化到O(1)。","link":"/2021/09/12/LeetCode7-53/"},{"title":"LeetCode 658.找到K个最接近的元素","text":"给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。 返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： |a - x| &lt; |b - x| 或者|a - x| == |b - x| 且 a &lt; b 示例 1： 12输入：arr = [1,2,3,4,5], k = 4, x = 3输出：[1,2,3,4] 解题思路1.排除法（双指针）我们可以反向来思考这道题，即删去n-k个最不接近的元素，剩下的元素即为最接近的k个。 我们设置指向头尾的两个指针left，right，每次删除掉相差更远的元素，对应指针向内缩减。 时间复杂度为$O(n)$ 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) { int n = arr.length; int left = 0; int right = n - 1; int removeNum = n - k; while(removeNum-- &gt; 0){ if(x - arr[left] &lt;= arr[right] - x){ right--; }else{ left++; } } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; k; i++){ list.add(arr[left + i]); } return list; }} 这里两数之差的比较没有采用绝对值，而是x - arr[left] &lt;= arr[right] - x，一种比较容易理解的方法是 x &lt;= (arr[left] + arr[right]) / 2; 2.二分查找我们要找最接近的k个数，当我们找到最优区间的最左边的那个数时，问题也相应解决。 这最优区间的最左边的数只会存在于区间 [0， n - k]。就可以通过二分查找在这区间中找到答案，设这个值为target。 令left = 0， right=n-k，二分mid=（left + right）/ 2, 二分的手段可以认为是一种随机选取，目的是通过二分可以快速排除不可能存在target的区间。 关键在于每次的判断条件，我们考虑 [mid, mid+k]这个k+1的区间，因为是k+1个数，我们必能够排除一个相对于x更远的数，同解法一类似，若arr[mid + k]与x更接近，则删除最左端也就是mid所指的数，因此mid及mid左边的数不可能是最优左边界（target），令left = mid + 1; 相反,则要删除最右端的数，导致的结果是mid的右边都不可能是target，令right = mid。通过这种判断手段，来在可能区间中定位target。 时间复杂度$O(logn + k)$ 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) { int n = arr.length; int left = 0; int right = n - k; int mid; while(left &lt; right){ mid = (left + right) /2; if(x - arr[mid] &gt; arr[mid + k] - x){ left = mid + 1; }else{ right = mid; } } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i&lt; k; i++){ list.add(arr[left + i]); } return list; }}","link":"/2021/12/29/LeetCode-658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/"},{"title":"数据结构和算法：双指针技巧","text":"双指针技巧，常用于数组和链表此类数据结构中，通过前后指针和快慢指针在单次遍历或少次遍历中求解问题 数组数组可以双向操作，双指针可前后遍历或同向遍历 167.两数之和Ⅱ-输入有序数组 easy： 给定一个已按照 非递减顺序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 。 使用双指针，分别从数组头尾遍历，若和小于目标值，则左指针右移，若大于目标值，则右指针左移。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int hi = numbers.size() - 1; int lo = 0; while(lo &lt; hi) { if(numbers[lo] + numbers[hi] == target) { return {lo + 1, hi + 1}; }else if(numbers[lo] + numbers[hi] &lt; target) { lo++; }else{ hi--; } } return {}; }}; 209.长度最小的子数组medium： 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 。 滑动窗口：定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和 初始状态下，start 和 end 都指向下标 0 ，sum 的值为 0。 每一轮迭代，将 nums[end] 加到 sum，如果 sum ≥ s，则更新子数组的最小长度，然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum &lt; s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int hi = numbers.size() - 1; int lo = 0; while(lo &lt; hi) { if(numbers[lo] + numbers[hi] == target) { return {lo + 1, hi + 1}; }else if(numbers[lo] + numbers[hi] &lt; target) { lo++; }else{ hi--; } } return {}; }}; 链表这里提到的链表都为单链表，因此常用同向的快慢指针 141.环形链表 easy: 给定一个链表，判断链表中是否有环，如果链表中存在环，则返回 true 。 否则，返回 false .快慢指针：涉及「Floyd 判圈算法」（又称龟兔赛跑算法） ​ 定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { if(head==nullptr || head-&gt;next==nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&gt;next; while(slow!=fast) { if(fast==nullptr || fast-&gt;next == nullptr) { return false; } fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } return true; }}; 142.环形链表Ⅱ medium：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null 快慢指针：定义两个指针fast和slow，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步，fast指针走过链表末端，说明链表无环； 当fast == slow时， 两指针在环中第一次相遇，设环长为b, 去掉环链长为a, 根据： ​ f = 2s （快指针每次2步，路程刚好2倍） ​ f = s + nb (相遇时，刚好多走了n圈） 推出：s = nb 从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。 如何知道slow刚好走了a步, 可以让一指针从head开始，和slow指针一起走，则相遇时刚好就是a步。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(!(fast == nullptr || fast-&gt;next == nullptr)){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast==slow){ fast = head; while(fast!=slow){ fast=fast-&gt;next; slow=slow-&gt;next; } return slow; } } return nullptr; }}; 160.相交链表 easy: 给你两个单链表的头节点 headA和headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 双指针：无论两链表是否相交，只需要将链表LA和链表LB的链尾对齐，然后从后向前依次比较节点是否相同即可。1.从后向前访问的第一节点既不是公共节点则两链表不相交。2.从后向前访问的公共节点中最后访问的公共节点则为两链表相交的第一个节点 因为单链表无法向前遍历节点，但是可以将LA+LB和LB+LA的两条轨道拼接起来，此时尾部对齐，从前往后遍历就能找到公共节点 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA==nullptr || headB==nullptr){ return nullptr; } ListNode* pA = headA; ListNode* pB = headB; while(pA != pB) { pA = pA == nullptr ? headB : pA-&gt;next; pB = pB == nullptr ? headA : pB-&gt;next; } return pA; }};","link":"/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"},{"title":"C语言实现五子棋游戏(AI算法实现)","text":"接上文C语言实现五子棋游戏，此文为AI算法的实现 主要为极大极小值搜索中应用Alpha-Beta剪枝 AI 算法算法思想AI算法主要思想是，电脑模拟人机双方下棋，并对落子后的局面进行评分，将分值构建成一棵树，再遍历寻找出最优解。 评估函数 首先要先实现对整个棋盘局面打分的评估函数，我设计了一个六元数组来识别五子棋的各种棋形，包括连五，活四，冲四等 然后设计一个各种棋形的权重表，用于打分，赋分有以下几个要点， 1.对于AI下棋的白棋方来说，将数值赋为正，黑棋棋形赋为负，并且相同棋形下黑棋的权重要更大，应为当AI白棋落子后即为黑子落子。 2.对于黑棋方(玩家)的连五，活四，冲四，活三等接近胜利的棋形权重要更大，同样原因是AI下完棋就到玩家下棋 3.棋形分值等级：连5&gt;活4&gt;冲4=活3&gt;眠3=活2&gt;眠2=活1，相邻等级的权重设置为相差20倍（也可以30，40倍），这是因为会重复计算等级比较低的棋型，以此避免影响总体判断。 设计各棋形的分值 123456789101112131415161718192021222324//棋子代号#define C_NONE 0#define C_BLACK 1#define C_WHITE 2//棋型代号 下标 权重#define OTHER 0//0,其他棋型不考虑#define WIN 1//100000,白赢#define LOSE 2//-10000000,黑赢#define FLEX4 3//50000,白活#define flex4 4//-80000,黑活#define BLOCK4 5//400#define block4 6//-80000#define FLEX3 7//400#define flex3 8//-8000#define BLOCK3 9//20#define block3 10//-40#define FLEX2 11//20#define flex2 12//-40#define BLOCK2 13//1#define block2 14//-2#define FLEX1 15//1#define flex1 16//-2 初始化棋形判别六元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189void init_tuple6type() { memset(tuple6type, 0, sizeof(tuple6type)); //白连5,ai赢 tuple6type[2][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][0] = WIN; tuple6type[0][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][1] = WIN; tuple6type[1][2][2][2][2][2] = WIN; tuple6type[3][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][3] = WIN; //黑连5,ai输 tuple6type[1][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][0] = LOSE; tuple6type[0][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][2] = LOSE; tuple6type[2][1][1][1][1][1] = LOSE; tuple6type[3][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][3] = LOSE; //白活4 tuple6type[0][2][2][2][2][0] = FLEX4; //黑活4 tuple6type[0][1][1][1][1][0] = flex4; //白活3 tuple6type[0][2][2][2][0][0] = FLEX3; tuple6type[0][0][2][2][2][0] = FLEX3; tuple6type[0][2][0][2][2][0] = FLEX3; tuple6type[0][2][2][0][2][0] = FLEX3; //黑活3 tuple6type[0][1][1][1][0][0] = flex3; tuple6type[0][0][1][1][1][0] = flex3; tuple6type[0][1][0][1][1][0] = flex3; tuple6type[0][1][1][0][1][0] = flex3; //白活2 tuple6type[0][2][2][0][0][0] = FLEX2; tuple6type[0][2][0][2][0][0] = FLEX2; tuple6type[0][2][0][0][2][0] = FLEX2; tuple6type[0][0][2][2][0][0] = FLEX2; tuple6type[0][0][2][0][2][0] = FLEX2; tuple6type[0][0][0][2][2][0] = FLEX2; //黑活2 tuple6type[0][1][1][0][0][0] = flex2; tuple6type[0][1][0][1][0][0] = flex2; tuple6type[0][1][0][0][1][0] = flex2; tuple6type[0][0][1][1][0][0] = flex2; tuple6type[0][0][1][0][1][0] = flex2; tuple6type[0][0][0][1][1][0] = flex2; //白活1 tuple6type[0][2][0][0][0][0] = FLEX1; tuple6type[0][0][2][0][0][0] = FLEX1; tuple6type[0][0][0][2][0][0] = FLEX1; tuple6type[0][0][0][0][2][0] = FLEX1; //黑活1 tuple6type[0][1][0][0][0][0] = flex1; tuple6type[0][0][1][0][0][0] = flex1; tuple6type[0][0][0][1][0][0] = flex1; tuple6type[0][0][0][0][1][0] = flex1; int p1, p2, p3, p4, p5, p6, x, y, ix, iy;//x:左5中黑个数,y:左5中白个数; ix:右5中黑个数,iy:右5中白个数 for (p1 = 0; p1 &lt; 4; ++p1) { for (p2 = 0; p2 &lt; 3; ++p2) { for (p3 = 0; p3 &lt; 3; ++p3) { for (p4 = 0; p4 &lt; 3; ++p4) { for (p5 = 0; p5 &lt; 3; ++p5) { for (p6 = 0; p6 &lt; 4; ++p6) { x = y = ix = iy = 0; if (p1 == 1)x++; else if (p1 == 2)y++; if (p2 == 1) { x++; ix++; } else if (p2 == 2) { y++; iy++; } if (p3 == 1) { x++; ix++; } else if (p3 == 2) { y++; iy++; } if (p4 == 1) { x++; ix++; } else if (p4 == 2) { y++; iy++; } if (p5 == 1) { x++; ix++; } else if (p5 == 2) { y++; iy++; } if (p6 == 1)ix++; else if (p6 == 2)iy++; if (p1 == 3 || p6 == 3) {//有边界 if (p1 == 3 &amp;&amp; p6 != 3) {//左边界 //白冲4 if (ix == 0 &amp;&amp; iy == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (ix == 4 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if (ix == 0 &amp;&amp; iy == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if (ix == 3 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if (ix == 0 &amp;&amp; iy == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if (ix == 2 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } else if (p6 == 3 &amp;&amp; p1 != 3) {//右边界 //白冲4 if (x == 0 &amp;&amp; y == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (x == 4 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //黑眠3 if (x == 3 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //白眠3 if (x == 0 &amp;&amp; y == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //黑眠2 if (x == 2 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //白眠2 if (x == 0 &amp;&amp; y == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } else {//无边界 //白冲4 if ((x == 0 &amp;&amp; y == 4) || (ix == 0 &amp;&amp; iy == 4)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if ((x == 4 &amp;&amp; y == 0) || (ix == 4 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if ((x == 0 &amp;&amp; y == 3) || (ix == 0 &amp;&amp; iy == 3)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if ((x == 3 &amp;&amp; y == 0) || (ix == 3 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if ((x == 0 &amp;&amp; y == 2) || (ix == 0 &amp;&amp; iy == 2)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if ((x == 2 &amp;&amp; y == 0) || (ix == 2 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } } } } } }} 基于以上的棋形分值和判别数组实现对当前棋盘的分值评估 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778EVALUATION evaluate(int(*board)[15]) { int weight[17] = { 0,1000000,-10000000,50000,-100000,400,-100000,400,-8000,20,-50,20,-50,1,-3,1,-3 };//各棋型权重 int type; int stat[4][17];//统计4个方向上每种棋型的个数 memset(stat, 0, sizeof(stat)); int STAT[17];//存在这种棋型的方向的个数 memset(STAT, 0, sizeof(STAT)); int A[17][17];//包括边界的虚拟大棋盘,3表示边界 for (int i = 0; i &lt; 17; ++i) A[i][0] = 3; for (int i = 0; i &lt; 17; ++i) A[i][16] = 3; for (int j = 0; j &lt; 17; ++j) A[0][j] = 3; for (int j = 0; j &lt; 17; ++j) A[16][j] = 3; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { A[i + 1][j + 1] = board[i][j]; } } //判断横向棋型 for (int i = 1; i &lt;= 15; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i][j + 1]][A[i][j + 2]][A[i][j + 3]][A[i][j + 4]][A[i][j + 5]]; stat[0][type]++; } } //判断竖向棋型 for (int j = 1; j &lt;= 15; ++j) { for (int i = 0; i &lt; 12; ++i) { type = tuple6type[A[i][j]][A[i + 1][j]][A[i + 2][j]][A[i + 3][j]][A[i + 4][j]][A[i + 5][j]]; stat[1][type]++; } } //判断左上至右下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i + 1][j + 1]][A[i + 2][j + 2]][A[i + 3][j + 3]][A[i + 4][j + 4]][A[i + 5][j + 5]]; stat[2][type]++; } } //判断右上至左下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 5; j &lt; 17; ++j) { type = tuple6type[A[i][j]][A[i + 1][j - 1]][A[i + 2][j - 2]][A[i + 3][j - 3]][A[i + 4][j - 4]][A[i + 5][j - 5]]; stat[3][type]++; } } EVALUATION eval;//评估结果 memset(eval.STAT, 0, sizeof(eval.STAT)); int score = 0; for (int i = 1; i &lt; 17; ++i) { score += (stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i]) * weight[i];//计分 int count = stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i];//统计所有方向上部分棋型的个数 if (i == WIN) eval.STAT[WIN] = count; else if (i == LOSE) eval.STAT[LOSE] = count; } eval.result = R_DRAW; //白赢 if (eval.STAT[WIN] &gt; 0)eval.result = R_WHITE; //黑赢 else if (eval.STAT[LOSE] &gt; 0)eval.result = R_BLACK; eval.score = score; return eval;} 极大极小值搜索算法的核心环节为极大极小值搜索，首先要引入博弈树的概念，就是将己方和敌方的决策构成树，每个节点的分支表示可走位置，每个叶节点表示一个局面。从根节点为0开始，奇数层表示电脑可能的走法，偶数层表示玩家可能的走法。假设电脑先手，那么第一层就是电脑的所有可能的走法，第二层就是玩家的所有可能走法，以此类推。电脑走棋的层我们称为 MAX层，这一层电脑要保证自己利益最大化，那么就需要选分最高的节点。玩家走棋的层我们称为MIN层，这一层玩家要保证自己的利益最大化，那么就会选分最低的节点。而每一个节点的分数，都是由子节点决定的，因此我们要对博弈树进行深度优先搜索，得到根节点的最佳选择。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int analyse(int(*board)[15], int depth, int alpha, int beta) { gameResult RESULT = evaluate(board).result; if (depth == 0 || RESULT != R_DRAW) {//如果模拟落子可以分出输赢，直接返回结果 if (depth == 0) { //搜索到最后一层 SOMEPOINTS P; P = seekPoints(board); //局部搜索与静态评价启发，直接寻找最佳的可能落子位置 return P.score[0]; //返回最佳位置对应的最高分 } else { return evaluate(board).score; //返回当前层分值 } } else if (depth % 2 == 0) {//max层,AI方(白)决策 int sameBoard[15][15]; copyBoard(board, sameBoard); SOMEPOINTS P = seekPoints(sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_WHITE;//模拟AI方落子 int a = analyse(sameBoard, depth - 1, alpha, beta);//递归搜索 sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE;//还原落子 if (a &gt; alpha) { alpha = a; if (depth == 4) {//搜索深度 decision.best.x = P.pos[i].x; //AI决策位置 decision.best.y = P.pos[i].y; decision.eval = a; } } if (beta &lt;= alpha)break; //Alpha-Beta剪枝 } return alpha; } else {//min层,玩家方(黑)决策 int rBoard[15][15]; reverseBoard(board, rBoard); SOMEPOINTS P = seekPoints(rBoard); //寻找黑子的最佳位置，需要反转棋盘颜色 int sameBoard[15][15]; copyBoard(board, sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_BLACK; int a = analyse(sameBoard, depth - 1, alpha, beta); sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE; if (a &lt; beta)beta = a; if (beta &lt;= alpha)break;//剪枝 } return beta; }} Alpha-Beta剪枝通过遍历博弈树来得到最佳的根节点，即使平均每一步只考虑50个节点，思考深度为四层(才具有一定算力)，搜索的节点数达50^4=6250000个。计算机需要多达100秒才可得到结果，因此我们必须对博弈树剪枝。 α-β剪枝算法应用于此类的极大极小值搜索，思想是在深度优先搜索下，对于提前已经排除选择结果外的节点进行剪枝。 具体实现为每一个节点对应有一个α和一个β，α表示目前该节点的最好下界，β表示目前该节点的最好上界。在最开始时，α为负无穷，β为正无穷。然后进行搜索，max层节点每搜索它的一个子节点，就要更新自己的α（下界），而min层节点每搜索它的一个子节点，就要更新自己的β（上界）。如果更新之后发现α&gt;=β了，说明后面的子节点已经不需要进行搜索了，直接剪枝掉。 进一步优化局部搜索对于每次模拟下棋的位置，只需考虑有棋子的附近，无需考虑整个棋盘，能有效减少节点，具体实现为考虑有落子的位置向周围延申三个深度。 静态评价启发将局部搜索得到的位置，先进行对当前局面的简单评估，只考虑分值较高的前十个节点，并将其排序，并有利于Alpha-Beta剪枝更早地发生。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950SOMEPOINTS seekPoints(int(*board)[15]) { bool B[15][15];//局部搜索,每个非空点附近8个方向延伸3个深度 int worth[15][15]; SOMEPOINTS best_points; memset(B, 0, sizeof(B)); for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (board[i][j] != C_NONE) { for (int k = -3; k &lt;= 3; ++k) { if (i + k &gt;= 0 &amp;&amp; i + k &lt; 15) { B[i + k][j] = true; if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i + k][j + k] = true; if (j - k &gt;= 0 &amp;&amp; j - k &lt; 15)B[i + k][j - k] = true; } if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i][j + k] = true; } } } } for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { worth[i][j] = -INT_MAX; if (board[i][j] == C_NONE &amp;&amp; B[i][j] == true) { //对局部搜索的每个位置评估 board[i][j] = C_WHITE; worth[i][j] = evaluate(board).score; board[i][j] = C_NONE; } } } int w; for (int k = 0; k &lt; 10; ++k) { //对分数排序出前十个位置 w = -INT_MAX; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (worth[i][j] &gt; w) { w = worth[i][j]; best_points.pos[k].x = i; best_points.pos[k].y = j; } } } best_points.score[k] = w; worth[best_points.pos[k].x][best_points.pos[k].y] = -INT_MAX;//清除掉上一点,计算下一点的位置和分数 } return best_points;} 至此，AI算法的实现基本完成，优化的结果能达到每步不到0.3秒得到结果。 写在最后此项目实现的五子棋游戏仍有很多不足之处，UI设计较为简陋，AI算法仍有很多提高之处。 完成项目的过程中也遇到了很多困难，也参考了许多教程和源代码，在此列出以表感谢。 陈可佳 博弈五子棋 livingsu 基于c++和qt实现五子棋ai 这是此项目的GitHub链接 github.com/Sami-zzz/gobang","link":"/2021/09/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F-AI%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"AI算法","slug":"AI算法","link":"/tags/AI%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"}],"categories":[{"name":"项目实践","slug":"项目实践","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}