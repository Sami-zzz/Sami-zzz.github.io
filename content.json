{"pages":[],"posts":[{"title":"C语言实现五子棋游戏(AI算法实现)","text":"接上文C语言实现五子棋游戏，此文为AI算法的实现 主要为极大极小值搜索中应用Alpha-Beta剪枝 AI 算法算法思想AI算法主要思想是，电脑模拟人机双方下棋，并对落子后的局面进行评分，将分值构建成一棵树，再遍历寻找出最优解。 评估函数 首先要先实现对整个棋盘局面打分的评估函数，我设计了一个六元数组来识别五子棋的各种棋形，包括连五，活四，冲四等 然后设计一个各种棋形的权重表，用于打分，赋分有以下几个要点， 1.对于AI下棋的白棋方来说，将数值赋为正，黑棋棋形赋为负，并且相同棋形下黑棋的权重要更大，应为当AI白棋落子后即为黑子落子。 2.对于黑棋方(玩家)的连五，活四，冲四，活三等接近胜利的棋形权重要更大，同样原因是AI下完棋就到玩家下棋 3.棋形分值等级：连5&gt;活4&gt;冲4=活3&gt;眠3=活2&gt;眠2=活1，相邻等级的权重设置为相差20倍（也可以30，40倍），这是因为会重复计算等级比较低的棋型，以此避免影响总体判断。 设计各棋形的分值 123456789101112131415161718192021222324//棋子代号#define C_NONE 0#define C_BLACK 1#define C_WHITE 2//棋型代号 下标 权重#define OTHER 0//0,其他棋型不考虑#define WIN 1//100000,白赢#define LOSE 2//-10000000,黑赢#define FLEX4 3//50000,白活#define flex4 4//-80000,黑活#define BLOCK4 5//400#define block4 6//-80000#define FLEX3 7//400#define flex3 8//-8000#define BLOCK3 9//20#define block3 10//-40#define FLEX2 11//20#define flex2 12//-40#define BLOCK2 13//1#define block2 14//-2#define FLEX1 15//1#define flex1 16//-2 初始化棋形判别六元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189void init_tuple6type() { memset(tuple6type, 0, sizeof(tuple6type)); //白连5,ai赢 tuple6type[2][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][0] = WIN; tuple6type[0][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][1] = WIN; tuple6type[1][2][2][2][2][2] = WIN; tuple6type[3][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][3] = WIN; //黑连5,ai输 tuple6type[1][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][0] = LOSE; tuple6type[0][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][2] = LOSE; tuple6type[2][1][1][1][1][1] = LOSE; tuple6type[3][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][3] = LOSE; //白活4 tuple6type[0][2][2][2][2][0] = FLEX4; //黑活4 tuple6type[0][1][1][1][1][0] = flex4; //白活3 tuple6type[0][2][2][2][0][0] = FLEX3; tuple6type[0][0][2][2][2][0] = FLEX3; tuple6type[0][2][0][2][2][0] = FLEX3; tuple6type[0][2][2][0][2][0] = FLEX3; //黑活3 tuple6type[0][1][1][1][0][0] = flex3; tuple6type[0][0][1][1][1][0] = flex3; tuple6type[0][1][0][1][1][0] = flex3; tuple6type[0][1][1][0][1][0] = flex3; //白活2 tuple6type[0][2][2][0][0][0] = FLEX2; tuple6type[0][2][0][2][0][0] = FLEX2; tuple6type[0][2][0][0][2][0] = FLEX2; tuple6type[0][0][2][2][0][0] = FLEX2; tuple6type[0][0][2][0][2][0] = FLEX2; tuple6type[0][0][0][2][2][0] = FLEX2; //黑活2 tuple6type[0][1][1][0][0][0] = flex2; tuple6type[0][1][0][1][0][0] = flex2; tuple6type[0][1][0][0][1][0] = flex2; tuple6type[0][0][1][1][0][0] = flex2; tuple6type[0][0][1][0][1][0] = flex2; tuple6type[0][0][0][1][1][0] = flex2; //白活1 tuple6type[0][2][0][0][0][0] = FLEX1; tuple6type[0][0][2][0][0][0] = FLEX1; tuple6type[0][0][0][2][0][0] = FLEX1; tuple6type[0][0][0][0][2][0] = FLEX1; //黑活1 tuple6type[0][1][0][0][0][0] = flex1; tuple6type[0][0][1][0][0][0] = flex1; tuple6type[0][0][0][1][0][0] = flex1; tuple6type[0][0][0][0][1][0] = flex1; int p1, p2, p3, p4, p5, p6, x, y, ix, iy;//x:左5中黑个数,y:左5中白个数; ix:右5中黑个数,iy:右5中白个数 for (p1 = 0; p1 &lt; 4; ++p1) { for (p2 = 0; p2 &lt; 3; ++p2) { for (p3 = 0; p3 &lt; 3; ++p3) { for (p4 = 0; p4 &lt; 3; ++p4) { for (p5 = 0; p5 &lt; 3; ++p5) { for (p6 = 0; p6 &lt; 4; ++p6) { x = y = ix = iy = 0; if (p1 == 1)x++; else if (p1 == 2)y++; if (p2 == 1) { x++; ix++; } else if (p2 == 2) { y++; iy++; } if (p3 == 1) { x++; ix++; } else if (p3 == 2) { y++; iy++; } if (p4 == 1) { x++; ix++; } else if (p4 == 2) { y++; iy++; } if (p5 == 1) { x++; ix++; } else if (p5 == 2) { y++; iy++; } if (p6 == 1)ix++; else if (p6 == 2)iy++; if (p1 == 3 || p6 == 3) {//有边界 if (p1 == 3 &amp;&amp; p6 != 3) {//左边界 //白冲4 if (ix == 0 &amp;&amp; iy == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (ix == 4 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if (ix == 0 &amp;&amp; iy == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if (ix == 3 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if (ix == 0 &amp;&amp; iy == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if (ix == 2 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } else if (p6 == 3 &amp;&amp; p1 != 3) {//右边界 //白冲4 if (x == 0 &amp;&amp; y == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (x == 4 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //黑眠3 if (x == 3 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //白眠3 if (x == 0 &amp;&amp; y == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //黑眠2 if (x == 2 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //白眠2 if (x == 0 &amp;&amp; y == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } else {//无边界 //白冲4 if ((x == 0 &amp;&amp; y == 4) || (ix == 0 &amp;&amp; iy == 4)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if ((x == 4 &amp;&amp; y == 0) || (ix == 4 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if ((x == 0 &amp;&amp; y == 3) || (ix == 0 &amp;&amp; iy == 3)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if ((x == 3 &amp;&amp; y == 0) || (ix == 3 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if ((x == 0 &amp;&amp; y == 2) || (ix == 0 &amp;&amp; iy == 2)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if ((x == 2 &amp;&amp; y == 0) || (ix == 2 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } } } } } }} 基于以上的棋形分值和判别数组实现对当前棋盘的分值评估 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778EVALUATION evaluate(int(*board)[15]) { int weight[17] = { 0,1000000,-10000000,50000,-100000,400,-100000,400,-8000,20,-50,20,-50,1,-3,1,-3 };//各棋型权重 int type; int stat[4][17];//统计4个方向上每种棋型的个数 memset(stat, 0, sizeof(stat)); int STAT[17];//存在这种棋型的方向的个数 memset(STAT, 0, sizeof(STAT)); int A[17][17];//包括边界的虚拟大棋盘,3表示边界 for (int i = 0; i &lt; 17; ++i) A[i][0] = 3; for (int i = 0; i &lt; 17; ++i) A[i][16] = 3; for (int j = 0; j &lt; 17; ++j) A[0][j] = 3; for (int j = 0; j &lt; 17; ++j) A[16][j] = 3; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { A[i + 1][j + 1] = board[i][j]; } } //判断横向棋型 for (int i = 1; i &lt;= 15; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i][j + 1]][A[i][j + 2]][A[i][j + 3]][A[i][j + 4]][A[i][j + 5]]; stat[0][type]++; } } //判断竖向棋型 for (int j = 1; j &lt;= 15; ++j) { for (int i = 0; i &lt; 12; ++i) { type = tuple6type[A[i][j]][A[i + 1][j]][A[i + 2][j]][A[i + 3][j]][A[i + 4][j]][A[i + 5][j]]; stat[1][type]++; } } //判断左上至右下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i + 1][j + 1]][A[i + 2][j + 2]][A[i + 3][j + 3]][A[i + 4][j + 4]][A[i + 5][j + 5]]; stat[2][type]++; } } //判断右上至左下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 5; j &lt; 17; ++j) { type = tuple6type[A[i][j]][A[i + 1][j - 1]][A[i + 2][j - 2]][A[i + 3][j - 3]][A[i + 4][j - 4]][A[i + 5][j - 5]]; stat[3][type]++; } } EVALUATION eval;//评估结果 memset(eval.STAT, 0, sizeof(eval.STAT)); int score = 0; for (int i = 1; i &lt; 17; ++i) { score += (stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i]) * weight[i];//计分 int count = stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i];//统计所有方向上部分棋型的个数 if (i == WIN) eval.STAT[WIN] = count; else if (i == LOSE) eval.STAT[LOSE] = count; } eval.result = R_DRAW; //白赢 if (eval.STAT[WIN] &gt; 0)eval.result = R_WHITE; //黑赢 else if (eval.STAT[LOSE] &gt; 0)eval.result = R_BLACK; eval.score = score; return eval;} 极大极小值搜索算法的核心环节为极大极小值搜索，首先要引入博弈树的概念，就是将己方和敌方的决策构成树，每个节点的分支表示可走位置，每个叶节点表示一个局面。从根节点为0开始，奇数层表示电脑可能的走法，偶数层表示玩家可能的走法。假设电脑先手，那么第一层就是电脑的所有可能的走法，第二层就是玩家的所有可能走法，以此类推。电脑走棋的层我们称为 MAX层，这一层电脑要保证自己利益最大化，那么就需要选分最高的节点。玩家走棋的层我们称为MIN层，这一层玩家要保证自己的利益最大化，那么就会选分最低的节点。而每一个节点的分数，都是由子节点决定的，因此我们要对博弈树进行深度优先搜索，得到根节点的最佳选择。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int analyse(int(*board)[15], int depth, int alpha, int beta) { gameResult RESULT = evaluate(board).result; if (depth == 0 || RESULT != R_DRAW) {//如果模拟落子可以分出输赢，直接返回结果 if (depth == 0) { //搜索到最后一层 SOMEPOINTS P; P = seekPoints(board); //局部搜索与静态评价启发，直接寻找最佳的可能落子位置 return P.score[0]; //返回最佳位置对应的最高分 } else { return evaluate(board).score; //返回当前层分值 } } else if (depth % 2 == 0) {//max层,AI方(白)决策 int sameBoard[15][15]; copyBoard(board, sameBoard); SOMEPOINTS P = seekPoints(sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_WHITE;//模拟AI方落子 int a = analyse(sameBoard, depth - 1, alpha, beta);//递归搜索 sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE;//还原落子 if (a &gt; alpha) { alpha = a; if (depth == 4) {//搜索深度 decision.best.x = P.pos[i].x; //AI决策位置 decision.best.y = P.pos[i].y; decision.eval = a; } } if (beta &lt;= alpha)break; //Alpha-Beta剪枝 } return alpha; } else {//min层,玩家方(黑)决策 int rBoard[15][15]; reverseBoard(board, rBoard); SOMEPOINTS P = seekPoints(rBoard); //寻找黑子的最佳位置，需要反转棋盘颜色 int sameBoard[15][15]; copyBoard(board, sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_BLACK; int a = analyse(sameBoard, depth - 1, alpha, beta); sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE; if (a &lt; beta)beta = a; if (beta &lt;= alpha)break;//剪枝 } return beta; }} Alpha-Beta剪枝通过遍历博弈树来得到最佳的根节点，即使平均每一步只考虑50个节点，思考深度为四层(才具有一定算力)，搜索的节点数达50^4=6250000个。计算机需要多达100秒才可得到结果，因此我们必须对博弈树剪枝。 α-β剪枝算法应用于此类的极大极小值搜索，思想是在深度优先搜索下，对于提前已经排除选择结果外的节点进行剪枝。 具体实现为每一个节点对应有一个α和一个β，α表示目前该节点的最好下界，β表示目前该节点的最好上界。在最开始时，α为负无穷，β为正无穷。然后进行搜索，max层节点每搜索它的一个子节点，就要更新自己的α（下界），而min层节点每搜索它的一个子节点，就要更新自己的β（上界）。如果更新之后发现α&gt;=β了，说明后面的子节点已经不需要进行搜索了，直接剪枝掉。 进一步优化局部搜索对于每次模拟下棋的位置，只需考虑有棋子的附近，无需考虑整个棋盘，能有效减少节点，具体实现为考虑有落子的位置向周围延申三个深度。 静态评价启发将局部搜索得到的位置，先进行对当前局面的简单评估，只考虑分值较高的前十个节点，并将其排序，并有利于Alpha-Beta剪枝更早地发生。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950SOMEPOINTS seekPoints(int(*board)[15]) { bool B[15][15];//局部搜索,每个非空点附近8个方向延伸3个深度 int worth[15][15]; SOMEPOINTS best_points; memset(B, 0, sizeof(B)); for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (board[i][j] != C_NONE) { for (int k = -3; k &lt;= 3; ++k) { if (i + k &gt;= 0 &amp;&amp; i + k &lt; 15) { B[i + k][j] = true; if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i + k][j + k] = true; if (j - k &gt;= 0 &amp;&amp; j - k &lt; 15)B[i + k][j - k] = true; } if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i][j + k] = true; } } } } for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { worth[i][j] = -INT_MAX; if (board[i][j] == C_NONE &amp;&amp; B[i][j] == true) { //对局部搜索的每个位置评估 board[i][j] = C_WHITE; worth[i][j] = evaluate(board).score; board[i][j] = C_NONE; } } } int w; for (int k = 0; k &lt; 10; ++k) { //对分数排序出前十个位置 w = -INT_MAX; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (worth[i][j] &gt; w) { w = worth[i][j]; best_points.pos[k].x = i; best_points.pos[k].y = j; } } } best_points.score[k] = w; worth[best_points.pos[k].x][best_points.pos[k].y] = -INT_MAX;//清除掉上一点,计算下一点的位置和分数 } return best_points;} 至此，AI算法的实现基本完成，优化的结果能达到每步不到0.3秒得到结果。 写在最后此项目实现的五子棋游戏仍有很多不足之处，UI设计较为简陋，AI算法仍有很多提高之处。 完成项目的过程中也遇到了很多困难，也参考了许多教程和源代码，在此列出以表感谢。 陈可佳 博弈五子棋 livingsu 基于c++和qt实现五子棋ai 这是此项目的GitHub链接 github.com/Sami-zzz/gobang","link":"/2021/09/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F-AI%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"},{"title":"C语言实现五子棋游戏","text":"C语言课设项目 基于C语言和EasyX图形库实现的五子棋小游戏 AI算法采用极大极小值搜索中应用Alpha-Beta剪枝 实现人机对战等功能 引言博弈算法 零和博弈，又称零和游戏或零和赛局，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有收入，其他方必有所失。 这里所提到的博弈算法适用于有完备信息的，确定性的，轮流行动的两个游戏者的零和游戏，像大多数的棋类游戏，如五子棋，象棋，围棋都满足这些条件，可以通过这套算法实现。 五子棋在今日已经被证明了是一种“不公平”的游戏，黑棋先手绝对占优，并且有先手必胜的套路。因此，五子棋发展出了各种限制黑棋的规则（如三三禁手），此类五子棋被称为“连珠”。 本文实现的五子棋为无禁手五子棋，AI算法较为简单，棋力水平达到业余水平。 界面设计此项目使用vs2019为开发工具，借助了EasyX图形库，实现较为简单的UI 程序基本结构123456789101112131415int main(){ while (1) { if (startGame() == 1) { //startGame函数为开始界面初始化 int win = game1(); //game1，game2函数分别实现人机和玩家pk gameOver1(win); } else { int win = game2(); gameOver2(win); } } return 0;} 开始页面其中涉及音乐和图片素材调用，素材文件路径可改变 涉及的EasyX图形库函数，可在EasyX文档中查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int startGame() { initgraph(600, 600); IMAGE im_start; loadimage(&amp;im_start, _T(&quot;D:\\\\素材\\\\start.jpg&quot;)); //开始界面图片 putimage(0, 0, &amp;im_start); setlinecolor(BLACK); //绘制选择按钮 setfillcolor(RGB(254, 220, 130)); fillrectangle(50, 490, 170, 545); fillrectangle(240, 490, 360, 545); fillrectangle(430, 490, 550, 545); setbkmode(TRANSPARENT); settextcolor(BLACK); LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(25, 0, _T(&quot;黑体&quot;)); outtextxy(60, 510, _T(&quot;人机对战&quot;)); outtextxy(250, 510, _T(&quot;双人游戏&quot;)); outtextxy(440, 510, _T(&quot;退出游戏&quot;)); settextstyle(&amp;nowstyle); mciSendString(_T(&quot;close stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;open D:\\\\素材\\\\background.mp3 alias bgmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play bgmusic repeat&quot;), NULL, 0, NULL); int gamemode = 0; init_tuple6type(); //调用初始化棋形函数，具体在AI算法中实现 while (1) { MOUSEMSG mouse = GetMouseMsg(); // if (mouse.x &gt;= 50 &amp;&amp; mouse.x &lt;= 170 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 1; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 240 &amp;&amp; mouse.x &lt;= 360 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 2; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 430 &amp;&amp; mouse.x &lt;= 550 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic wait&quot;), NULL, 0, NULL); exit(0); } } mciSendString(_T(&quot;close bgmusic&quot;), NULL, 0, NULL); return gamemode;} 棋盘数据 棋盘数据由结构体数组储存 12345678typedef struct node { //棋盘每个节点的数据储存 int x; //左上顶点坐标 int y; int model; //格子边框样式 int value; //是否落子（0代表无, 黑棋1, 白棋2） bool isnew; //是否显示选择框 COLORREF color; //格子颜色}NODE; 全局变量 12NODE map[15][15];COLORREF COLOR = RGB(255, 183, 111); 棋盘绘制 初始化棋盘数组中的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void initNode(){ for (int i = 75, k = 0; i &lt;= 495; i = i + 30) { for (int j = 75, g = 0; j &lt;= 495; j = j + 30) { map[k][g].x = j; map[k][g].y = i; map[k][g].value = 0; map[k][g].isnew = false; map[k][g].color = COLOR; if (k == 0 &amp;&amp; g == 0) //根据格子位置判断格子边框 { map[k][g].model = 8; } else if (k == 0 &amp;&amp; g == 14) { map[k][g].model = 7; } else if (k == 14 &amp;&amp; g == 14) { map[k][g].model = 6; } else if (k == 14 &amp;&amp; g == 0) { map[k][g].model = 5; } else if (k == 0) { map[k][g].model = 3; } else if (k == 14) { map[k][g].model = 4; } else if (g == 0) { map[k][g].model = 1; } else if (g == 14) { map[k][g].model = 2; } else if ((k == 3 &amp;&amp; g == 3) || (k == 3 &amp;&amp; g == 11) || (k == 11 &amp;&amp; g == 3) || (k == 11 &amp;&amp; g == 11) || (k == 7 &amp;&amp; g == 7)) { map[k][g].model = 9; } else { map[k][g].model = 0; } g++; } k++; } } 下棋时，棋盘会随着鼠标移动显示选择框，避免不断绘制整个棋盘导致的闪屏，于是将棋盘绘制设计为每个格子逐个绘制，在更新选择框时仅重新绘制当前位置的图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138void drawNode(NODE* node){ int x = node-&gt;x; //获得当前节点数据 int y = node-&gt;y; int model = node-&gt;model; int value = node-&gt;value; int isnew = node-&gt;isnew; COLORREF color = node-&gt;color; setfillcolor(color); solidrectangle(x, y, x + 30, y + 30); //绘制边框 setlinecolor(BLACK); switch (model) { case 0: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); break; // * // * * * // * case 3: setlinestyle(PS_SOLID, 2); line(x + 15, y + 15, x + 15, y + 30); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * * * // * // * case 4: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * // * // * * * case 1: setlinestyle(PS_SOLID, 2); line(x + 14, y + 15, x + 30, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 2: setlinestyle(PS_SOLID, 2); line(x - 1, y + 15, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 7: setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 15, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 6: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x - 1, y + 15, x + 15, y + 15); break; // * // * // * * * case 5: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x + 15, y + 15, x + 30, y + 15); break; // * // * // * * * case 8: setlinestyle(PS_SOLID, 3); line(x + 15, y + 15, x + 30, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 9: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); setfillcolor(BLACK); setlinestyle(PS_SOLID, 2); fillcircle(x + 15, y + 15, 4); break; // * // * O * // * } //绘制选择框 if (isnew) { setlinestyle(PS_SOLID, 2); setlinecolor(LIGHTGRAY); line(x + 1, y + 2, x + 8, y + 2); line(x + 2, y + 1, x + 2, y + 8); line(x + 29, y + 2, x + 22, y + 2); line(x + 29, y + 1, x + 29, y + 8); line(x + 2, y + 29, x + 8, y + 29); line(x + 2, y + 22, x + 2, y + 29); line(x + 29, y + 29, x + 22, y + 29); line(x + 29, y + 22, x + 29, y + 29); } //绘制棋子 switch (value) { case 1: setfillcolor(BLACK); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; case 2: setfillcolor(WHITE); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; }} 绘制整个棋盘函数，不断调用绘制格子函数 12345678910111213141516171819202122232425262728293031void drawBoard(){ //更新每一个节点 for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { drawNode(&amp;map[i][j]); if (map[i][j].isnew == true) { map[i][j].isnew = false; // 把上一个下棋位置的选择框清除 } } } // 绘制坐标 TCHAR strnum[19][3] = { _T(&quot;1&quot;),_T(&quot;2&quot;) ,_T(&quot;3&quot;) ,_T(&quot;4&quot;),_T(&quot;5&quot;) ,_T(&quot;6&quot;) ,_T(&quot;7&quot;),_T(&quot;8&quot;),_T(&quot;9&quot;),_T(&quot;10&quot;), _T(&quot;11&quot;),_T(&quot;12&quot;) ,_T(&quot;13&quot;) ,_T(&quot;14&quot;),_T(&quot;15&quot;) }; TCHAR strabc[19][3] = { _T(&quot;A&quot;),_T(&quot;B&quot;) ,_T(&quot;C&quot;) ,_T(&quot;D&quot;),_T(&quot;E&quot;) ,_T(&quot;F&quot;) ,_T(&quot;G&quot;),_T(&quot;H&quot;),_T(&quot;I&quot;),_T(&quot;J&quot;), _T(&quot;K&quot;),_T(&quot;L&quot;) ,_T(&quot;M&quot;) ,_T(&quot;N&quot;),_T(&quot;O&quot;) }; LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(0, 0, NULL); settextcolor(BLACK); int number = 0; for (int i = 0; i &lt; 15; i++) { outtextxy(85 + number, 60, strnum[i]); outtextxy(60, 85 + number, strabc[i]); number += 30; } } 游戏函数 game1为实现人机对战的函数，其中关于AI算法函数稍后实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int game1() { //人机对战实现 Sleep(500); setbkcolor(COLOR); cleardevice(); initNode(); drawBoard(); settextstyle(20, 10, 0, 0, 0, 1000, false, false, false); settextcolor(BLACK); settextstyle(25, 0, NULL); outtextxy(90, 530, _T(&quot;玩家执黑先行&quot;)); int whoplay = 0; int oldi = 0; //更新鼠标位置所储存的坐标 int oldj = 0; while (1) { if (whoplay == 0) { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); MOUSEMSG mouse = GetMouseMsg(); if (mouse.x &gt;= 75 &amp;&amp; mouse.y &gt;= 75 &amp;&amp; mouse.x &lt;= 525 &amp;&amp; mouse.y &lt;= 525) { //判断鼠标所处节点 int j = (mouse.x - 75) / 30; int i = (mouse.y - 75) / 30; //判断是否是空位置 if (map[i][j].value == 0) { // 如果按下了 if (mouse.mkLButton) { map[i][j].value = C_BLACK; // 下棋 map[i][j].isnew = true; //更新选择框 whoplay = 1; //轮到下一个 drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { //判断是否获胜 return win; } oldi = 0; oldj = 0; continue; } // 更新节点 map[oldi][oldj].isnew = false; drawNode(&amp;map[oldi][oldj]); map[i][j].isnew = true; drawNode(&amp;map[i][j]); oldi = i; oldj = j; } } } else { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); int board[15][15]; mapToBoard(map, board); //AI下棋 analyse(board, 4, -INT_MAX, INT_MAX); //AI算法实现函数，应用极大极小值搜索 map[decision.best.x][decision.best.y].value = C_WHITE; map[decision.best.x][decision.best.y].isnew = true; whoplay = 0; drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { return win; } oldi = 0; oldj = 0; } }} 胜负判断 每次落子后调用胜负判断函数，若有一方胜出则结束游戏 123456789101112131415161718192021222324252627282930313233343536373839404142int winner(){ int iswin = 0; int dx[4] = { 1, 0, 1, 1 }; //向四种方向搜索棋盘 int dy[4] = { 0, 1, 1, -1 }; bool isfull = true; for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { if (map[i][j].value != 0) { int nowcolor = map[i][j].value; int length[4] = { 0, 0, 0, 0 }; for (int k = 0; k &lt; 4; k++) { int nowi = i; int nowj = j; while (map[nowi][nowj].value == nowcolor &amp;&amp; nowi &gt;= 0 &amp;&amp; nowi &lt;= 14 &amp;&amp; nowj &gt;= 0 &amp;&amp; nowj &lt;= 14) { length[k]++; nowi += dx[k]; nowj += dy[k]; } } for (int k = 0; k &lt; 4; k++) { if (length[k] &gt;= 5) { if (nowcolor == C_BLACK) { iswin = 1; } else { iswin = 2; } } } } else { isfull = false; } } } if (isfull) { iswin = 3; } return iswin;} 五子棋界面设计差不多已经完成，AI下棋的算法在下一篇 C语言实现五子棋游游戏(AI算法实现)","link":"/2021/07/16/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F/"},{"title":"ES6笔记","text":"ES6 ES6简介 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言 90%的浏览器都支持ES6，也可以通过 babel 编译器（一个 js 编译器）将 ES5 代码 转为 ES6 代码 let和const let 声明变量没有变量提升 let 是一个块作用域，let声明的变量只在它所在的代码块有效。在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ） let 不可以重复声明 const 声明常量，一旦声明就不能被修改，除此之外也有 let 的三个特性。 开发中，默认情况下用 const，而只有在你知道变量值需要被修改的情况下使用 let 模板字符串 模板字符串：使用 tab 键的反引号 ` 插入变量时：使用 ${ 变量名 } 12345678910const oBox = document.querySelector('.box')let id = 1, name = '牛肉粉';// ES6 写法let htmlStr = `&lt;ul&gt; &lt;li&gt; &lt;p id = ${id} &gt; ${name} &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;`oBox.innerHTML = htmlStr; 函数默认值和剩余参数 函数默认值 1234567891011121314function add(a = 10, b = 20){ //设置默认值 return a + b;}console.log(add()); // 30function add(a, b = getVal(5)) { //默认值可以是函数 return a + b;} function getVal(val) { return val + 5;} console.log(add(10)); 剩余参数 ：由…和一个紧跟着的具名参数组成 : …keys …keys 解决了 arguments 的问题 12345function checkArgs(...args){ console.log(args); // 返回一个真实的实参数组[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] console.log(arguments); // 返回一个实参伪数组}checkArgs('a','b','c'); 扩展运算符剩余参数与扩展运算符的区别： 剩余参数：把多个独立的合并到一个数组中 扩展运算符：将一个数组分割，并将各个项作为分离的参数传给函数 1234// Math.max 获取最大值 const arr = [10, 20, 50, 30, 90, 100, 40];// 扩展运算符更方便console.log(Math.max(...arr)) // 100 箭头函数 使用 =&gt; 来定义 , function(){} 等价于 () =&gt; {} ，代码变得更加简洁 箭头函数内部没有 arguments 箭头函数不能使用 new 关键字来实例化对象，function 函数也是一个对象，但是箭头函数不是 123456789let add = function(a, b){ return a + b;} // 上下两者写法等价 let add = (a, b) =&gt; { return a + b;} this指向 箭头函数没有this的指向，箭头函数内部的this值只能通过查找作用域链来确定 解构赋值 解构赋值是对赋值运算符的一种扩展。它通常针对数组和对象进行操作。 优点：代码书写简洁且易读性高 12345678910111213141516171819202122let node = { type:'iden', name:'foo'} let {type,name} = node;console.log(type,name) //剩余运算符 使用此法将其它属性展开到一个对象中存储let {a,...res} = obj;console.log(a,res);// 默认值 a 的值 20 ，b 的值 30let {a,b = 30} = {a:20}; //对数组的解构let [a, b] = [1, 2, 3];console.log(a,b) //可嵌套let [a, [b], c] = [1, [2], 3] 对象扩展 **Object.is()**： 比较两个值是否严格相等 1234console.log(NaN === NaN)console.log(+0 === -0)console.log(Object.is(NaN, NaN))console.log(Object.is(+0, -0)) Object.assign() Object.assign(target, obj1, obj2...)方法用于对象的合并，将原对象（obj）的所有属性，复制到目标对象（target） 12let obj = Object.assign({}, {a:1}, {b:2})console.log(obj) Symbol类型 它表示的是独一无二的值 最大的用途：用来定义对象的私有变量 如果用 Symbol 定义的是对象中的变量，取值时一定要用 [变量名] 如果用 Symbol 定义的是对象中的变量，该变量不能作为key，无法用 for 循环遍历 123456789101112const name1 = Symbol('name')const name2 = Symbol('name')console.log(name1 === name2)let s1 = Symbol('s1')let person = { [s1]: 'qwe'}console.log(person[s1]) Set和MapSet 集合：表示无重回复值的有序列表 123456789101112131415161718192021//newlet set1 = new Set()set1.add(1)set1.add('1')console.log(set1)console.log(set1.size)set1.delete('1')console.log(set1.has('1'))set1.add(2)set1.add(3)set1.add(4)//遍历for(let k of set1){ console.log(k)}//set去重let set2 = new Set([1,2,3,3,3,4])console.log(set2)let arr = [...set2]console.log(arr) Map：键值对的有序列表，键和值是任意类型 1234567891011121314let map1 = new Map()map1.set('name', '张三')console.log(map1)console.log(map1.get('name'))map1.delete('name')console.log(map1.has('name'))map1.set(['a', [1, 2, 3]], 'asd')console.log(map1)//初始化let map2 = new Map([['a', 1], ['b', 2]])console.log(map2) 数组的扩展方法 Array.from()方法用于将伪数组转为真正的数组 123456789101112function add(){ let arr1 = Array.from(arguments) console.log(arr1)}add(1,2,3)let lis = document.querySelectorAll('li')let arr = Array.from(lis)console.log(arr)let arr2 = Array.from(lis, ele =&gt; ele.textContent)console.log(arr2) Array.of()方法用于将一组值，转换为数组 12let arr3 = Array.of(1, 2, '3', [1, 2], {id:1})console.log(arr3) copyWithin(target, start = 0, end = this.length); 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 ​ start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 ​ end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 ​ 这三个参数都应该是数值，如果不是，会自动转为数值。 12let arr4 = [1,2,3,8,9,10].copyWithin(0, 3)console.log(arr4) // [8, 9, 10, 8, 9, 10] find() 方法：找出第一个符合条件的数组成员，它的参数是一个回调函数。 findIndex() 方法：找出第一个符合条件的数组成员的索引 12345let num = [1,2,-10, 8, -1].find( n =&gt; n &lt; 0)console.log(num)let numIndex = [1,2,-10, 8, -1].findIndex( n =&gt; n &lt; 0)console.log(numIndex) ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是： keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 12345678910111213let arr5 = [1, 2, 4, 7, 3]console.log(arr5.keys())for(let k of arr5.keys()){ console.log(k)}for(let v of arr5.values()){ console.log(v)}for(let [k, v] of arr5.entries()){ console.log(k, v)} includes() 返回一个布尔值，表示某个数组是否包含给定的值 注意：以前的 indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，返回值是1或-1，所以要去比较是否不等于-1，表达起来不够直观 1console.log(arr5.includes(5)) Iterator遍历器 遍历器（Iterator）它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员），快捷的访问数据。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 Iterator 的遍历过程是这样的。 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 1234567let items = ['one', 'two', 'three'];//创建一个遍历器let ite = items[Symbol.iterator]();console.log(ite.next()) // { value: 'one', done: false }console.log(ite.next()) // { value: 'two', done: false }console.log(ite.next()) // { value: 'three', done: false }console.log(ite.next()) // { value: undefined, done: true } Generator函数（生成器） Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回一个遍历器对象。而 Generator 函数也是遍历器生成函数，可以把 Generator 函数赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口，给不具备 Iterator 接口的数据结构（不自带Symbol.iterator方法）提供遍历操作。 形式上，Generator 函数是一个普通函数，但是有两个特征（区别）。一是，function关键字与函数名之间有一个星号 * ；二是，函数体内部使用yield表达式 Generator 函数是分段执行的，只有调用next方法才会遍历下一个内部状态。yield是暂停执行标志，next()是恢复执行。当 next() 传入参数时，该参数就会被当作上一个 yield 表达式的返回值 1234567891011121314151617181920212223242526272829function* fun(){ console.log('one') yield 'one' console.log('two') yield 'two' }let fn = fun()console.log(fn)console.log(fn.next())console.log(fn.next())console.log(fn.next())console.log(&quot;****************&quot;)function* add(){ console.log('one ') let x = yield 'one' console.log('two ' + 'x:' + x) let y = yield 'two' console.log('add ' + 'y:' + y) return x + y}let fn2 = add()console.log(fn2.next())console.log(fn2.next(10))console.log(fn2.next(30)) 使用场景：为不具备 Iterator 接口的对象提供了遍历操作 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口（不具备 Symbol.iterator方法），无法使用for...of循环，通过 Generator 函数为它加上这个接口，即将 Generator 函数加到对象的Symbol.iterator属性上面，就可以用了。 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 1234567891011121314151617181920212223242526272829303132333435let person = { name: '张三', age: 12, address: 'China' } function* ObjectEntries(obj){ const propKeys = Object.keys(obj) for(const propKey of propKeys){ yield [propKey, obj[propKey]] } } for(let [k, v] of ObjectEntries(person)){ console.log(k, v) } console.log(...ObjectEntries(person)) console.log(&quot;************&quot;) function* ObjectEntries2(){ const propKeys = Object.keys(this) for(const propKey of propKeys){ yield [propKey, this[propKey]] } } person[Symbol.iterator] = ObjectEntries2 for(let [k, v] of person){ console.log(`${k} ${v}`) } console.log(...person) console.log({name, age, address} = person) Generator 函数在加载页面的异步应用 1234567891011121314151617181920212223function* load(){ loadUI() yield showData() hideUI()}let iteload = load()iteload.next()function loadUI(){ console.log('加载loading...页面')}function showData(){ setTimeout(() =&gt; { console.log('数据加载完成') iteload.next() }, 1000);}function hideUI(){ console.log('隐藏loading...页面')} Promise对象 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果 Promise 是一个对象，Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。axios 的内部实现原理就是通过 Promise 实现的 Promise对象有以下两个特点： 对象的状态不受外界影响。有三种状态：pending（进行中）、fulfilled（成功）和rejected（失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为resolved和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果 Promise对象是一个构造函数，用来生成Promise实例，带有一个回调函数，回调函数的两个参数是 resolve（成功） 和 reject（失败）,这两个参数他们也是函数。 then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。 1234567891011121314151617181920212223242526//基本使用 let pro = new Promise(function(resolved, rejected){ //执行异步操作 let res = { code: 201, data: { name: 'asd' }, error: '失败了' } setTimeout(() =&gt; { if(res.code === 200){ resolved(res.data) }else{ rejected(res.error) } }, 1000) }) console.log(pro) pro.then((val) =&gt; { console.log(val) }, (err) =&gt; { console.log(err) }) 1234567891011121314151617181920212223242526//封装的Promise function timeOut(ms){ return new Promise(function(resolved, rejected){ //执行异步操作 let res = { code: 200, data: { name: 'asd' }, error: '失败了' } setTimeout(() =&gt; { if(res.code === 200){ resolved(res.data) }else{ rejected(res.error) } }, ms) }) } timeOut(2000).then((val) =&gt; { console.log(val) }) 123456789101112131415161718192021222324252627//使用Promise封装Ajax const getJSON = function(url){ return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest() xhr.open('GET', url) xhr.responseType = 'json' xhr.setRequestHeader('Accept', 'application/json') xhr.send() xhr.onreadystatechange = handler function handler(){ if(this.readyState === 4){ if(this.status === 200){ resolve(this.response.HeWeather6) }else{ reject(new Error(this.statusText)) } } } }) } let a = getJSON('https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976') .then((data) =&gt; { console.log(data[0]) }).catch((err) =&gt; { console.log(err) }) 如果一个promise执行完后 返回的还是一个promise 实例（注意，不是原来那个Promise实例），会把这个promise 的执行结果，传递给下一次then中。因此可以采用链式写法，即then方法后面再调用另一个then方法。 catch(err=&gt;{})方法等价于then(null,err=&gt;{})，用于指定发生错误时的回调函数 resolve()方法将现有对象转换成Promise对象，该实例的状态为 fulfilled 成功 123456//resolve() reject()let p = Promise.resolve('foo')console.log(p)p.then((data) =&gt; { console.log(data)}) reject()方法和resolve()方法一样返回一个新的Promise实例,该实例的状态为 rejected（失败） 12345let p2 = Promise.reject(new Error('出错了'));//等价于 let p2 = new Promise((resolve,reject)=&gt;reject(new Error('出错了)));p2.catch(err =&gt; { console.log(err);}) all(): all()方法提供了并行执行异步操作的能力，并且再所有异步操作执行完后才执行回调 应用：一些游戏类的素材比较多，等待所有图片，静态资源都加载完成，才进行页面的初始化 123456789101112//all()let p1 = new Promise(resolve =&gt; resolve())let p2 = new Promise(resolve =&gt; resolve())let p3 = new Promise(resolve =&gt; resolve())let p4 = Promise.all([p1, p2, p3])p4.then(() =&gt; {}).catch(() =&gt; {}) Promise.all()接受一个promise对象的数组，待全部完成之后，统一执行success; race(): 接受一个包含多个promise对象的数组，只要有一个完成，就执行success 应用：当我们请求某个图片资源，会导致时间过长，给用户反馈 用race给某个异步请求设置超时时间，并且在超时后执行相应的操作 1234567891011121314151617181920212223242526//race() function requestImg(ImgSrc){ return new Promise((resolve, reject) =&gt; { const img = new Image() img.onload = function(){ resolve(img) } img.src = ImgSrc }) } function timeout(){ return new Promise((resolev, reject) =&gt; { setTimeout(() =&gt; { reject(new Error('请求图片失败')) }, 3000) }) } Promise.race([requestImg(''), timeout()]).then((data) =&gt; { console.log(data) }).catch((err) =&gt; { console.log(err) }).done(() =&gt; { }) done()和finally() async异步操作async 函数，它就是 Generator 函数的语法糖 作用：使得异步操作更加方便 凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象 123456async function test() { } let result = test()console.log(result) //即便代码里test函数什么都没返回，我们依然打出了Promise对象 await必须在async函数里使用，不能单独使用 await的作用之一就是获取后面Promise对象成功状态传递出来的参数传给 then 函数。 123456789async function f() { /* ** 如果 await 命令后面的不是一个Promise实例对象， ** await 命令会自动把await后面转为一个Promise实例对象 */ return await 'hello async';}// 因为返回的是一个Promise实例对象，所以可以用链式编程 f().then(v =&gt; {console.log(v)}).catch(e =&gt; {console.log(e)}); 如果 async 函数中有多个 await , 那么 then 函数 会等待所有的 await 指令运行完才去执行 123456async function f(){ let s = await 'hello world' let data = await s.split(''); return data;}f().then(v =&gt; {console.log(v)}).catch(e =&gt; {console.log(e)}); 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。 1234567891011121314151617181920async function f(){ await Promise.reject('出错了'); await Promise.resolve('hello');}f().then(v =&gt; {console.log(v)}).catch(e =&gt; {console.log(e)}); //输出 出错了 /*** async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，** 变成了 reject 状态，catch方法的回调函数被调用*/ async function f2() { await new Promise(function (resolve, reject) { // 抛出一个错误对象 throw new Error('出错了'); });} f2().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了 针对上诉遇到 reject状态，就中断执行的问题，可以通过 try…catch 代码块解决 1234567891011async function f() { try { await Promise.reject('出错了'); } catch (error){ } return await Promise.resolve('hello'); });} f2().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e)) // 输出 hello class的用法1234567891011121314151617181920212223242526272829303132333435363738394041424344// es5 /*function Person(name, age) { this.name = name; this.age = age;}Person.prototype.sayName = function() { return this.sayName;}let p = new Person('牛肉粉',18);console.log(p);*/ // es6class Person { // 实例化的时候会立即被调用 constructor(name, age){ this.name = name; this.age = age; } //等同于Person.prototype = function sayName(){} sayName(){ return this.name; } sayAge(){ return this.age; }}// 小技巧：通过 Objec.assign() 方法(详见对象的扩展功能)一次性向类中添加多个方法/*Object.assign(Person.prototype, { sayName(){ return this.name; } sayAge(){ return this.age; }})*/ let p = new Person('牛肉粉',18);console.log(p);p.sayName();p.sayAge(); 类的继承 1234567891011121314151617181920212223242526272829303132333435class Animal { // 实例化的时候会立即被调用 constructor(name, age){ this.name = name; this.age = age; } sayName(){ return this.name; } sayAge(){ return this.age; }} class Dog extends Animal{ constructor(name, age, color){ // 如果 子类 继承了 父类，且 子类 中写了构造器，则 子类 构造器的 super 必须要调用 super(name, age); // 等同于 Animal.call(this,name,age); 继承父类的属性 this.color = color; } // 子类自己的方法 sayColor(){ return `${this.name}是${this.age}岁了，它的颜色是${this.color}`; } // 重写父类的方法 sayName(){ // super 相同于 Animal return this.name + super.sayAge + this.color; }} let d1 = new Dog('小黄', 28, 'red');console.log(d1.sayAge()); // 调用继承父类的方法console.log(d1.sayColor()); // 调用子类自己的方法console.log(d1.sayName()); // 调用重写父类的方法 模块化 ES6 模块功能主要有两个命令构成：export 和 import export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 1234567891011121314//module/index.jsexport const name = '张三';export const age = 18;export const sayName = function() { console.log(fristName);} //也可以这样const name = '张三';const age = 18;const sayName = function() { console.log(fristName);}export {name, age, sayName} 12//main.jsimport {name, age, sayName} from './modules/index.js';//解构赋值 {name, age, sayName} 使用export default命令为模块指定默认输出，在其它模块加载该模块时，import命令可以为该匿名函数指定任意名字 1234567891011//export-default.jsexport default function(){ console.log('foo');} //或者写成function foo() { console.log('foo');} export default foo; 如果想在一条import语句中，同时输入默认方法（default）和其他接口（非default），可以写成下面这样 12345678//export-default.jsexport default function(){ console.log('foo');} export function add(){ console.log('add')} 123456import customName,{add} from 'export-default.js' // 方式二 * 代表所有属性和方法 as 代表重命名import * as f from 'export-default.js' console.log(f); // 输出一个 模块, 里面保存了 export 传过来的所有属性和方法console.log(f.default); export default也可以用来输出类 123456// MyClass.jsexport default class Person{ ... } // main.jsimport Person from 'MyClass';let o = new Person(); 数组方法ES5 indexof(): 用于查找数组中是否存在某个值，如果存在则返回某个值的下标，否则返回-1 1234let list = [1, 2, 3];console.log(list.indexOf(2)) // 1console.log(list.indexOf(&quot;蛙人&quot;)) // -1 map():map是一个数组函数方法，接收三个参数，value，index，self，返回值是处理完的结果，返回新数组。 123456789let list = [1, 2, 3];const res = list.map((value, key, self) =&gt; { console.log(value) // 1 2 3 console.log(key) // 0 1 2 console.log(self) // [1, 2, 3] return value * 2})console.log(res) foreach():用于遍历一个数组，接收三个参数，value，index，self，返回值为undefined 123456789let list = [1, 2, 3];const res = list.forEach((value, key, self) =&gt; { console.log(value) // 1 2 3 console.log(key) // 0 1 2 console.log(self) // [1, 2, 3] return 123})console.log(res) // undefined splice(): 用于数组删除或替换内容，接收三个参数： 第一个参数是，删除或添加的位置 第二个参数是，要删除的几位，如果为0则不删除 第三个参数是，向数组添加内容 12345678910let list = [1, 2, 3];list.splice(0, 1) // 把第0个位置，给删除一位console.log(list) // [2, 3]list.splice(0, 1, &quot;蛙人&quot;) // 把第0个位置，给删除一位，添加上一个字符串console.log(list) // [&quot;蛙人&quot;, 2, 3]list.splice(0, 2, &quot;蛙人&quot;) // 把第0个位置，给删除2位，添加上一个字符串console.log(list) // [&quot;蛙人&quot;, 3] slice():用于截取数组值，接收两个参数，第一个参数是要获取哪个值的下标，第二个参数是截取到哪个下标的前一位。 1234let list = [1, 2, 3];let res = list.slice(1, 3) // 从第一位下标开始截取，到第三位下标的前一位，所以截取出来就是 [2, 3]console.log(res) // [2, 3] filter():用于过滤数组内的符合条件的值，返回值为满足条件的数组对象 1234let list = [1, 2, 3];let res = list.filter(item =&gt; item &gt; 1);console.log(res) // [2, 3] every():用于检测数组所有元素是否都符合指定条件，返回值为Boolean , 该方法是数组中必须全部值元素满足条件返回true，否则false 1234567let list = [1, 2, 3];let res = list.every(item =&gt; item &gt; 0)console.log(res) // truelet res1 = list.every(item =&gt; item &gt; 1)console.log(res1) // false some():用于检测数组中的元素是否满足指定条件，返回值为Boolean , 该方法是只要数组中有一项满足条件就返回true，否则false 1234let list = [1, 2, 3];let res = list.some(item =&gt; item &gt; 0)console.log(res) // true reduce(): 该方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。该方法回调函数接收四个参数 第一个参数：初始值, 或者计算结束后的返回值 第二个参数：当前元素 第二个参数：当前元素的索引 第四个参数：当前元素所属的数组对象，本身 我们一般只用前两个就行，reduce第一个参数回调函数，第二个参数是初始值 1&gt;reduce(function(previousValue, currentValue, currentIndex, array) { /* … */ }, initialValue) callbackFn 一个“reducer”函数，包含四个参数： previousValue：上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 initialValue，其值则为 initialValue，否则为数组索引为 0 的元素 array[0]。 currentValue：数组中正在处理的元素。在第一次调用时，若指定了初始值 initialValue，其值则为数组索引为 0 的元素 array[0]，否则为 array[1]。 currentIndex：数组中正在处理的元素的索引。若指定了初始值 initialValue，则起始索引号为 0，否则从索引 1 起始。 array：用于遍历的数组。 initialValue 可选 作为第一次调用 callback 函数时参数 previousValue 的值。若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素；否则 previousValue 将使用数组第一个元素，而 currentValue 将使用数组第二个元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 pop() 删除并返回数组的最后一个元素 shift() 删除并返回数组的第一个元素 reverse() 颠倒数组中元素的顺序。 join():用于数据以什么形式拼接 1234567let list = [1, 2, 3];let res = list.join(&quot;-&quot;);console.log(res) // 1-2-3let sum = eval(list.join(&quot;+&quot;))console.log(sum) // 6 sort():可之间排序，或使用回调函数，用于将数组排序，排序规则看返回值 1234let list = [1, 2, 3];let sort = list.sort((a, b) =&gt; b - a)console.log(sort) // [3, 2, 1] concat(): 用于合并数组原始 1234let list = [1, 2, 3];let res = list.concat([1, 2, 3])console.log(res) // [1, 2, 3, 1, 2, 3] Array.isArray():检测对象是不是一个数组 1234let list = [1, 2, 3];let res = Array.isArray(list)console.log(res) // true","link":"/2022/10/09/ES6%E7%AC%94%E8%AE%B0/"},{"title":"JS 基础总结","text":"基础总结初始JavaScript JavaScript 是一种运行在客户端的脚本语言 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 现在也可以基于 Node.js 技术进行服务器端编程 浏览器执行JS简介浏览器分成两部分：渲染引擎和 JS 引擎 渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit JS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8 JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行 JS的组成JavaScript 包括 ECMAScript、DOM、BOM ECMAScriptECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 DOM文档对象模型文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。 BOM浏览器对象模型浏览器对象模型（Browser Object Model，简称BOM），提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 JS初体验JS引入方式 行内式 1&lt;input type=&quot;button&quot; value=&quot;&quot; onclink=&quot;javascript:alert('Hello World')&quot; /&gt; 可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性)，如： onclink 注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号 内嵌式JS 123&lt;script&gt; alert('Hello World!');&lt;/script&gt; 可以将多行JS代码写到&lt;script&gt;标签中 内嵌 JS 是学习时常用的方式 外部JS 1&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt; 引用外部JS文件的script标签中间不可以写代码 基本语法注释 单行注释 1// 单行注释 多行注释 123/* 多行注释*/ 输入输出语句 方法 说明 归属 alert(msg); 浏览器弹出警示框 浏览器 console.log(msg); 浏览器控制台打印信息（主要给程序员看） 浏览器 prompt(info); 浏览看弹出输入框，用户可以输入 浏览器 变量初始化 var是一个JS关键字，用来声明变量(variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间。 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 1234//声明变量同时赋值为18var age = 18; //同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。var age = 18, address ='火影村',salary = 15000; 特殊情况 情况 说明 结果 var age; console.log(age); 只声明，不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10;console.log(age); 不声明 只赋值 10 命名规范数据类型JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。 JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型 12var x = 6; //x为数字var x = &quot;Bill&quot;; //x为字符串 基本数据类型 简单数据类型 说明 默认值 Number 数字型，包含整型值和浮点型值，如21，0.21 0 Boolean 布尔值类型，如true，false ，等价于1和0 false Undefined var a; 声明了变量a但是没有赋值，此时a=undefined undefined（未定义的） string 字符串类型，如“张三” “” Null var a = null; 声明了变量a为空值 null 数字型Number12var age = 12; //整数var Age = 21.3747; //小数 在JS中八进制前面加0，十六进制前面加 0x 数字型范围 最大值：Number.MAX_VALUE 最小值：Number.MIN_VALUE 三个特殊值 Infinity：无穷大 -Infinity：无穷小 NaN：Not a Number ,代表任何一个非数值 isNaN()：方法用来判断非数字，并且返回一个值，如果是数字返回的是false，如果不是数字返回的是true 123456var userAge = 21;var isOk = isNan(userAge);console.log(isOk); //false,21不是一个非数字var userName = &quot;andy&quot;;console.log(isNan(userName)); //true,&quot;andy&quot;是一个非数字 字符串型string12var strMsg = &quot;我爱北京天安门&quot;; //使用双引号表示字符串var strMsg = '我爱北京'; //使用单引号表示字符串 字符串引号嵌套 12var strMsg ='我是一个&quot;高富帅&quot;' //可以用 ' ' 包含 &quot; &quot;var strMsg2 =&quot;我是'高富帅'&quot; //可以用&quot; &quot; 包含 '' 字符串转义符 字符串长度：通过length属性获取 12var strMsg = &quot;我是高富帅！&quot;;alert(strMsg.length); //显示6 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 布尔型Boolean 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12var flag = true;console.log(flag + 1); // 2 true当加法来看当1来看，flase当0来看 未定义undefined 一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果 123456// 如果一个变量声明未赋值，就是undefined 未定义数据类型var str;console.log(str); //undefinedvar variable = undefined;console.log(variable + 'Pink'); //undefinedPink undefined 和 字符串 相加，会拼接字符串console.log(variable + 18); //NaN undefined 和 数字相加，最后结果是NaN 空值 一个声明变量给 null 值，里面存的值为空 123var space = null;console.log(space + 'pink'); //nullpinkconsole.llog(space + 1); // 1 typeof typeof 可用来获取检测变量的数据类型, 空值结果为object 数据类型转换使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。 转换为字符串型 方式 说明 案例 toString() 转成字符串 var num = 1; alert(num.toString()); String()强制转换 转成字符串 var num = 1; alert(String(num)); 加号拼接字符串 和字符串拼接的结果都是字符串 var num =1; alert(num+“我是字符串”); 转换为数字型 方式 说明 案例 parselnt(string)函数 将string类型转成整数数值型 parselnt(‘78’) parseFloat(string)函数 将string类型转成浮点数数值型 parseFloat(‘78.21’) Number()强制转换函数 将string类型转换为数值型 Number(‘12’) js 隐式转换**( - * / ) ** 利用算术运算隐式转换为数值型 ‘12’-0 转换为布尔型 方法 说明 案例 Boolean()函数 其他类型转成布尔值 Boolean(‘true’); 代表空，否定的值会被转换为false，如 ’ ’ , 0, NaN , null , undefined 其余的值都会被被转换为true 运算符运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号 算数运算符1+ - * / % 浮点数精度问题： 浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数 12var result = 0.1 +0.2; //结果不是0.3，0.30000000000000004console.log(0.07 * 100); //结果不是7，而是7.000000000000001 递增和递减运算符比较运算符 运算符名称 说明 案例 结果 &lt; 小于号 1 &lt; 2 true &gt; 大于号 1 &gt; 2 false &gt;= 大于等于号(大于或者等于) 2 &gt;= 2 true &lt;= 小于等于号(小于或者等于) 3 &lt;= 2 false == 判等号(会隐式转型) 37 == 37 true != 不等号 37 != 37 false === 全等 要求值和数据类型都一致 37 === ‘37’ false 逻辑运算符&amp;&amp; || ！ 赋值运算符= += -= *= /= %= 流程控制分支，循环 数组创建数组 利用new创建数组 1var arr = new Array(); //创建一个新的空数组 数组字面量创建 123456// 1.利用数组字面量方式创建空的数组 var 数组名 = [];// 2.使用数组字面量方式创建带初始值的数组var 数组名 = ['小白','小黑','小黄','瑞奇'];// 3.数组中可以存放任意类型的数据，例如字符串，数字，布尔值等var arrStus = ['小白', 12, true, 28.9]; 数组索引（下标）遍历数组for循环 数组长度12var arrStus = [1,2,3];alert(arrStus.length); // 3 数组中新增元素 通过修改length长度新增数组元素 可以通过修改 length 长度来实现数组扩容的目的 123456var arr = ['red', 'green', 'blue', 'pink'];arr.length = 7;console.log(arr);console.log(arr[4]);console.log(arr[5]);console.log(arr[6]); //其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 undefined length 属性是可读写的 通过修改数组索引新增数组元素 可以通过修改数组索引的方式追加数组元素 123var arr = ['red', 'green', 'blue', 'pink'];arr[4] = 'hotpink';console.log(arr); 函数函数声明 利用函数关键字function自定义函数 123456//声明函数function fn(){ //函数体代码}// 调用 可以写在函数声明前面fn(); 函数表达式声明 1234// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...};// 调用的方式，函数调用必须写到函数体下面fn(); 调用函数12//调用函数函数名(); //通过调用函数名来执行函数体代码 函数的参数12345678// 声明函数function getSum(num1,num2){ console.log(num1+num2)}// 调用函数getSum(1,3) //4getSum(6，5) //11 形参和实参个数不匹配 参数个数 说明 实参个数等于形参个数 输出正确结果 实参个数多于形参个数 只取到形参的个数 实参个数小于形参个数 多的形参定义为undefined，结果为NaN 123456789function sum(num1, num2) { console.log(num1 + num2);}sum(100, 200); // 300，形参和实参个数相等，输出正确结果sum(100, 400, 500, 700); // 500，实参个数多于形参，只取到形参的个数sum(200); // 实参个数少于形参，多的形参定义为undefined，结果为NaN 函数的返回值 如果函数没有return，返回的值是undefined 函数只能返回一个值，如果用逗号隔开多个值，以最后一个为准 arguments的使用当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。 arguments展示形式是一个伪数组，因此可以进行遍历 具有length属性 可以按索引存储数据 不具有数组的push，pop等方法 作用域JavaScript (ES6前) 中的作用域有两种： 全局作用域 局部作用域(函数作用域) 全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件 局部（函数）作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域 JS没有块级作用域(在ES6之前) 12345if(true){ int num = 123; System.out.println(num); // 123}System.out.println(num); // 123 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种：全局变量和局部变量 全局变量在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量） 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量 局部变量 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 作用域链1234567891011// 作用域链: 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链表var num = 10;funtion fn() { //外部函数 var num = 20; function fun() { //内部函数 console.log(num); // 20 ,一级一级访问 }}//作用域链：采取就近原则的方式来查找变量最终的值。 预解析JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行 预解析：js引擎会把js里面所有的 var 还有 function 提升到当前作用域的最前面 代码执行：从上到下执行JS语句 变量预解析变量预解析也叫做变量提升 变量提升: 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升 12345678console.log(num); // 结果是多少？var num = 10; // undefined//相当于执行了以下代码var num; // 变量声明提升到当前作用域最上面console.log(num);num = 10; // 变量的赋值不会提升 函数预解析函数预解析也叫做函数提升 函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数 匿名函数(函数表达式方式): 函数调用必须写在函数声明的下面 123456789101112// 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面fn();var fn = function() { console.log('22'); // 报错}//相当于执行了以下代码var fn;fn(); //fn没赋值，没这个，报错var fn = function() { console.log('22'); //报错} 对象在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等 创建对象利用字面量创建对象对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法 { } 里面采取键值对的形式表示 12345678910var star = { name : 'pink', age : 18, sex : '男', sayHi : function(){ alert('大家好啊~'); }};// 多个属性或者方法中间用逗号隔开// 方法冒号后面跟的是一个匿名函数 对象调用 属性调用：1.对象.属性名 2.对象[‘属性名’] 函数调用：对象.方法名() 123console.log(star.name) // 调用名字属性console.log(star['name']) // 调用名字属性star.sayHi(); // 调用 sayHi 方法,注意，一定不要忘记带后面的括号 利用new Object创建对象创建方式：var 对象名 = new Object(); 使用格式：对象.属性 = 值 1234567891011var obj = new Object(); //创建了一个空的对象obj.name = '张三丰';obj.age = 18;obj.sex = '男';obj.sayHi = function() { console.log('hi~');}console.log(obj.name);console.log(obj['sex']);obj.sayHi(); 利用构造函数创建对象构造函数 ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。 1234567//构造函数的语法格式function 构造函数名() { this.属性 = 值; this.方法 = function() {}}new 构造函数名(); 1234567891011121314151617181920212223//1. 构造函数名字首字母要大写//2. 构造函数不需要return就可以返回结果//3. 调用构造函数必须使用 new//4. 我们只要new Star() 调用函数就创建了一个对象//5. 我们的属性和方法前面必须加thisfunction Star(uname,age,sex) { this.name = uname; this.age = age; this.sex = sex; this.sing = function(sang){ console.log(sang); }}var ldh = new Star('刘德华',18,'男');console.log(typeof ldh) // object对象，调用函数返回的是对象console.log(ldh.name);console.log(ldh['sex']);ldh.sing('冰雨');//把冰雨传给了sangvar zxy = new Star('张学友',19,'男'); 构造函数名字首字母要大写 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 遍历对象的属性 for...in 语句用于对数组或者对象的属性进行循环操作 12345for(var k in obj) { console.log(k); //这里的 k 是属性名 console.log(obj[k]);//这里的 obj[k] 是属性值} 内置对象 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象 JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 Math对象Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 1234567891011121314151617Math.PI // 圆周率Math.floor() // 向下取整Math.ceil() // 向上取整Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值 Math.random() // 随机返回一个小数，取值为[0，1),console.log(Math.PI); console.log(Math.max(1,99,3)); // 99// 得到两个数之间的随机整数，并且包含这两个整数function getRandom(min,max) { return Math.floor(Math.random() * (max - min + 1)) + min;}console.log(getRandom(1,10)); Date()日期对象 Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用 Date 实例用来处理日期和时间 Date()方法的使用12345678910var now = new Date(); //首先要实例化，没有参数则返回当前系统的时间console.log(now);// 2.参数常用的写法 数字型 2019,10,1 字符串型 '2019-10-1 8:8:8' 时分秒// 如果Date()里面写参数，就返回括号里面输入的时间 var data = new Date(2019,10,1);console.log(data); // 返回的是11月不是10月var data2 = new Date('2019-10-1 8:8:8');console.log(data2); 日期格式化 方法名 说明 getFullYear() 获取当年 getMonth() 获取当月**(0-11)** getDate() 获取当天日期 getDay() 获取星期几**(周日0到周六6)** getHours() 获取当前小时 getMinutes() 获取当前小时 getSeconds() 获取当前秒钟 valueOf() 得到现在时间距离1970.1.1总的毫秒数 getTime() 得到现在时间距离1970.1.1总的毫秒数 获取日期总的毫秒形式12345678910111213141516// 获取Date总的毫秒数 不是当前时间的毫秒数 而是距离1970年1月1号过了多少毫秒数// 实例化Date对象var date = new Date();// 1 .通过 valueOf() getTime() 用于获取对象的原始值console.log(date.valueOf()); //得到现在时间距离1970.1.1总的毫秒数console.log(date.getTime());// 2.简单的写法var date1 = +new Date(); // +new Date()返回的就是总的毫秒数，console.log(date1);// 3. HTML5中提供的方法 获得总的毫秒数 有兼容性问题console.log(Date.now()); 倒计时效果 123456789101112131415function() countDown(time){ var nowTime = +new Date(); //没有参数，返回的是当前时间总的毫秒数 var inputTime = +new Date(time); // 有参数，返回的是用户输入时间的总毫秒数 var times = (inputTime - nowTime) / 1000 //剩余时间的总的秒数 var d = parseInt(times / 60 / 60 / 24); //天数 d &lt; 10 ? '0' + d : d; var h = parseInt(times / 60 / 60 % 24); //小时 h &lt; 10 ? '0' + h : h; var m = parseInt(times / 60 % 60); //分 m &lt; 10 ? '0' + m : m; var s = parseInt(times % 60); //秒 s &lt; 10 ? '0' + s : s; return d + '天' + h + '时' + m + '分' + s + '秒';} 数组对象创建方式12var arr1 = [1, 2, 3]; //1.字面量方式var arr2 = new Array(2, 3); //2.new Array() 检测是否为数组 instanceof 运算符，可以判断一个对象是否属于某种类型 Array.isArray() 用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 123456var arr = [1, 23];var obj = {};console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // falseconsole.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素 方法名 说明 返回值 push(参数1…) 末尾添加一个或多个元素，会修改原数组 并返回新的长度 pop() 删除数组最后一个元素 返回它删除的元素的值 unshift(参数1…) 向数组的开头添加一个或更多元素，注意修改原数组 并返回新的长度 shift() 删除数组的第一个元素，数组长度减1，无参数，修改原数组 并返回第一个元素 数组排序 方法名 说明 是否修改原数组 reverse() 颠倒数组中元素的顺序，无参数 该方法会改变原来的数组，返回新数组 sort() 对数组的元素进行排序 该方法会改变原来的数组，返回新数组 1234567var arr = [1,64,9,61];arr.sort( function(a,b) { return b - a; //降序的排列 return a - b; //升序 }) 查找元素索引 方法名 说明 返回值 indexOf() 数组中查找给定元素的第一个索引 如果存在返回索引号，如果不存在，则返回-1 lastIndexOf() 在数组的最后一个索引，从后向前索引 如果存在返回索引号，如果不存在，则返回-1 数组转换为字符串 方法名 说明 返回值 toString() 把数组转换成字符串，逗号分隔每一项 返回一个字符串 join(‘分隔符’) 方法用于把数组中的所有元素转换为一个字符串 返回一个字符串 12345678// 1.toString() 将我们的数组转换为字符串var arr = [1, 2, 3];console.log(arr.toString()); // 1,2,3// 2.join('分隔符')var arr1 = ['green', 'blue', 'red'];console.log(arr1.join()); // 不写默认用逗号分割console.log(arr1.join('-')); // green-blue-redconsole.log(arr1.join('&amp;')); // green&amp;blue&amp;red 其他方法 方法名 说明 返回值 concat() 连接两个或多个数组 不影响原数组 返回一个新的数组 slice() 数组截取slice(begin,end) 返回被截取项目的新数组 splice() 数组删除splice(第几个开始要删除的个数) 返回被删除项目的新数组，这个会影响原数组 字符串对象基本包装类型为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 12var str = 'andy';console.log(str.length); 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1.生成临时变量,把简单类型包装为复杂数据类型var temp = new String('andy');// 2.赋值给我们声明的字符变量str = temp;// 3.销毁临时变量temp = null; 字符串不可变：指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 返回字符索引字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 方法名 说明 indexOf(‘要查找的字符’，开始的位置) 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号 lastIndexOf() 从后往前找，只找第一个匹配的 返回索引字符 charAt(index) 返回指定位置的字符(index字符串的索引号) str.charAt(0) charCodeAt(index) 获取指定位置处字符的ASCII码(index索引号) str.charCodeAt(0) str[index] 获取指定位置处字符 HTML,IE8+支持和charAt()等效 字符串操作方法 方法名 说明 concat(str1,str2,str3…) concat() 方法用于连接两个或对各字符串。拼接字符串 substr(start,length) 从 start 位置开始(索引号), length 取的个数。 slice(start,end) 从 start 位置开始，截取到 end 位置 ，end 取不到 (两个都是索引号) substring(start,end) 从 start 位置开始，截取到 end 位置 ，end 取不到 (基本和 slice 相同，但是不接受负) 其他方法 方法名 说明 replace(‘a’, ‘b’) 用于在字符串中用一些字符替换另一些字符 split() 用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组 toUpperCase() 转换大写 toLowerCase() 转换小写 123var str = 'a,b,c,d';console.log(str.split(','));// 返回的是一个数组 ['a', 'b', 'c', 'd']","link":"/2022/04/30/JS-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"title":"JS BOM技术","text":"BOMBOM概述BOM（ Browser Object Model ）浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window BOM的构成 BOM 比 DOM 更大，它包含 DOM。 window 对象是浏览器的顶级对象，它具有双重角色 它是 JS 访问浏览器窗口的一个接口 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法 在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt()等。 window对象的常见事件窗口加载事件window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像，脚本文件，CSS文件等），就调用的处理函数。 1234567window.onload = function(){ //里面可以写JS代码};window.addEventListener(&quot;load&quot;,function(){}); 有了window.onload就可以把JS代码写到页面元素的上方 因为onload是等页面内容全部加载完毕，再去执行处理函数 window.onload 传统注册事件方式，只能写一次，以最后一个为准 如果使用addEventListener 则没有限制 1document.addEventListener('DOMContentLoaded',function(){}) DOMCountentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded事件比较合适。 调整窗口大小事件window.onresize 是调整窗口大小加载事件，当触发时就调用的处理函数 123window.onresize = function() {}// 或者window.addEventListener('resize',function(){}); 只要窗口大小发生像素变化，就会触发这个事件 我们经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕的宽度 定时器window 对象给我们提供了两个定时器 setTimeout() setInterval() setTimeout()定时器setTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。 1window.setTimeout(调用函数,[延迟的毫秒数]); window可以省略 这个调用函数 可以直接写函数 或者写函数名 或者采取字符串 ‘函数名()’ （不推荐） 延迟的毫秒数省略默认是0，如果写，必须是毫秒 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符 setTimeout() 这个调用函数我们也称为回调函数 callback 普通函数是按照代码顺序直接调用，而这个函数，需要等待事件，事件到了才会去调用这个函数，因此称为回调函数。 123456789101112131415&lt;body&gt; &lt;script&gt; setTimeout(function(){ console.log('boom!!!'); }, 3000) function fn(){ console.log('boooom!'); } var timer1 = setTimeout(fn, 3000); var timer2 = setTimeout(fn, 5000); &lt;/script&gt;&lt;/body&gt; clearTimeout()停止定时器clearTimeout()方法取消了先前通过调用 setTimeout()建立的定时器 1window.clearTimeout(timeoutID) window可以省略 里面的参数就是定时器的标识符 setInterval()定时器setInterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数 用法和注意点同setTimeout() 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次 clearInterval()停止定时器 clearInterval() 方法取消了先前通过调用 setInterval() 建立的定时器 倒计时效果案例 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt; &lt;script&gt; var hour = document.querySelector('.hour'); var minute = document.querySelector('.minute'); var second = document.querySelector('.second'); var inputTime = +new Date('2022-5-1 18:00:00'); //全局变量，设置倒计时时间 countDown(); //定时器会延迟，所以每次刷新页面先执行一次 setInterval(countDown, 1000); function countDown(){ var nowTime = +new Date(); var times = (inputTime - nowTime) / 1000; var h = parseInt(times / 60 / 60 % 24); h = h &lt; 10 ? '0' + h : h; hour.innerHTML = h; //写入时间 var m = parseInt(times / 60 % 60); m = m &lt; 10 ? '0' + m : m; minute.innerHTML = m; var s = parseInt(times % 60); s = s &lt; 10 ? '0' + s : s; second.innerHTML = s; } &lt;/script&gt;&lt;/body&gt; 发送短信案例 12345678910111213141516171819202122&lt;body&gt; 发送短信: &lt;input type=&quot;text&quot;&gt; &lt;button&gt;发送&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); var time = 9; //设置剩余时间的全局变量，每次减一 btn.addEventListener('click', function(){ //点击发送后 btn.disabled = true; //禁用按钮 var timer = setInterval(function(){ if(time == 0){ //减到零 clearInterval(timer); btn.disabled = false; btn.innerHTML = '发送'; time = 9; }else{ btn.innerHTML = '还剩'+ time +'秒可以重新发送'; time--; } }, 1000) }) &lt;/script&gt;&lt;/body&gt; this指向 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁 现阶段，我们先了解一下几个this指向 全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window) 方法调用中谁调用this指向谁 构造函数中this指向实例对象 JS执行机制JS是单线程JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 同步和异步为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，于是，JS 中出现了同步和异步 同步：前一个任务结束后再执行后一个任务 异步：在做这件事的同时，你还可以去处理其他事情 同步任务同步任务都在主线程上执行，形成一个 执行栈 异步任务 JS中的异步是通过回调函数实现的 异步任务有以下三种类型 普通事件，如click,resize等 资源加载，如load,error等 定时器，包括setInterval,setTimeout等 异步任务相关回调函数添加到任务队列中 执行过程 先执行执行栈中的同步任务 异步任务由异步进程处理放到任务队列(执行时才放入任务队列) 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop） location对象window 对象给我们提供了一个 location属性用于获取或者设置窗体的url，并且可以解析url。 url统一资源定位符（uniform resouce locator）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 url 的一般语法格式为： 123protocol://host[:port]/path/[?query]#fragmenthttp://www.itcast.cn/index.html?name=andy&amp;age=18#link 组成 说明 protocol 通信协议 常用的http,ftp,maito等 host 主机(域名) www.itheima.com port 端口号，可选 path 路径 由零或多个'/'符号隔开的字符串 query 参数 以键值对的形式，通过&amp;符号分隔开来 fragment 片段 #后面内容 常见于链接 锚点 location 对象属性 location对象属性 返回值 location.href 获取或者设置整个URL location.host 返回主机（域名）www.baidu.com location.port 返回端口号，如果未写返回空字符串 location.pathname 返回路径 location.search 返回参数 location.hash 返回片段 #后面内容常见于链接 锚点 案例：5s后跳转页面12345678910111213141516171819&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var btn = document.querySelector('button'); var div = document.querySelector('div'); var timer = 5; setInterval(function() { if (timer == 0) { location.href = 'http://www.itcast.cn'; } else { div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页'; timer--; } }, 1000); &lt;/script&gt;&lt;/body&gt; 获取URL参数实现登录页面login.html到首页index.html的跳转，表单的提交 login.html 1234567&lt;body&gt; &lt;form action=&quot;index.html&quot;&gt; 用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt; index.html 123456789101112131415&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; console.log(location.search); // ?uname=andy // 1.先去掉？ substr('起始的位置'，截取几个字符); var params = location.search.substr(1); // uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split('='); var arr = params.split('='); console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;] var div = document.querySelector('div'); // 3.把数据写入div中 div.innerHTML = arr[1] + '欢迎您'; &lt;/script&gt;&lt;/body&gt; location对象方法 location对象方法 返回值 location.assign() 跟href一样，可以跳转页面（也称为重定向页面），可以后退 location.replace() 替换当前页面，因为不记录历史，所以不能后退页面 location.reload() 重新加载页面，相当于刷新按钮或者 f5 ，如果参数为true 强制刷新 ctrl+f5 navigator对象navigator 对象包含有关浏览器的信息，它有很多属性 我们常用的是userAgent,该属性可以返回由客户机发送服务器的user-agent头部的值 下面代码可以判断用户是用哪个终端打开页面的，如果是用 PC 打开的，我们就跳转到 PC 端的页面，如果是用手机打开的，就跳转到手机端页面 123456if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = &quot;&quot;; //手机 } else { window.location.href = &quot;&quot;; //电脑 } history对象window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互 该对象包含用户（在浏览器窗口中）访问过的 URL。 history对象方法 作用 back() 可以后退功能 forward() 前进功能 go(参数) 前进后退功能，参数如果是 1 前进1个页面 如果是 -1 后退1个页面 123456789101112&lt;body&gt; &lt;a href=&quot;list.html&quot;&gt;点击我去往列表页&lt;/a&gt; &lt;button&gt;前进&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button'); btn.addEventListener('click', function() { // history.forward(); history.go(1); }) &lt;/script&gt;&lt;/body&gt; PC端网页特效元素偏移量offsetoffset概述我们使用offset系列相关属性可以动态地得到该元素的位置（偏移）、大小等 获得元素距离带有定位的父元素的偏移量 获得元素自身的大小（宽度高度） 返回的数值都不带单位 offset系列属性 作用 element.offsetParent 返回该元素带有定位的父级元素，如果没有则返回body element.offsetTop 返回元素带有定位的父元素上方的偏移，如果没有则返回body的偏移 element.offsetLeft 返回元素带有定位的父元素左边的偏移，如果没有则返回body的偏移 element.offsetWidth 返回自身包括padding、边框、内容区的宽度 element.offsetHeight 返回自身包括padding、边框、内容区的宽度 offset和style的区别 offset style offset可以得到任意样式表中的样式值 style只能得到行内样式表的样式值 offset系列获得的数值时没有单位的 style.width获得的是带有单位的字符串 offsetWidth包含padding+border+width style获得不包含padding和border的值 offsetWidth等属性是只读属性，只能获取不能赋值 style.width是可读写属性，可以获取也可以赋值 想要获取元素大小位置，用offset更合适 想要给元素更改值，则使用style 拖拽模态框案例点击链接，显示登录框和遮罩背景，鼠标在登录框标题位置按下，可以移动登录框 123456789101112131415161718192021222324252627282930&lt;script&gt; var login = document.querySelector('.login'); //登录框 var mask = document.querySelector('.login-bg'); //背景 var link = document.querySelector('#link'); //点击链接 var closeBtn = document.querySelector('#closeBtn'); //关闭按钮 var title = document.querySelector('#title'); //登录框标题栏 //点击链接，显示遮罩和登录框 link.addEventListener('click', function(){ login.style.display = 'block'; mask.style.display = 'block'; }) //点击关闭按钮，去除遮罩和登录框 closeBtn.addEventListener('click',function(){ login.style.display = 'none'; mask.style.display = 'none'; }) //点击登录框标题，实现鼠标按下移动效果 title.addEventListener('mousedown', function(e){ var x = e.pageX - login.offsetLeft; //获得鼠标在距离登录框的偏移量，在按下 var y = e.pageY - login.offsetTop; //之后这两个值为固定值 document.addEventListener('mousemove', move); //在整个页面移动 function move(e){ login.style.left = e.pageX - x + 'px'; //更改登录框位置 login.style.top = e.pageY - y + 'px'; } document.addEventListener('mouseup', function(){ //在鼠标弹起后移除事件 document.removeEventListener('mousemove', move); }) }) &lt;/script&gt; 放大镜效果 页面结构搭建：在小图片盒子里放入一个遮罩盒子，采取定位方式，再在小盒子里放入一个大的图片盒子，在右边显示，也采用定位的方式，在这大图片盒子里放入大图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//使用外部的js文件window.addEventListener('load', function() { var preview_img = document.querySelector('.preview_img'); //小图片盒子 var mask = document.querySelector('.mask'); //遮罩 var big = document.querySelector('.big'); //大图片盒子 // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子 preview_img.addEventListener('mouseover', function() { mask.style.display = 'block'; big.style.display = 'block'; }) preview_img.addEventListener('mouseout', function() { mask.style.display = 'none'; big.style.display = 'none'; }) // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走 preview_img.addEventListener('mousemove', function(e) { // (1). 先计算出鼠标在盒子内的坐标 var x = e.pageX - this.offsetLeft; var y = e.pageY - this.offsetTop; // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了 // (3) 我们mask 移动的距离 var maskX = x - mask.offsetWidth / 2; var maskY = y - mask.offsetHeight / 2; // (4) 如果x 坐标小于了0 就让他停在0 的位置 // 遮挡层的最大移动距离 var maskMax = preview_img.offsetWidth - mask.offsetWidth; if (maskX &lt;= 0) { maskX = 0; } else if (maskX &gt;= maskMax) { maskX = maskMax; } if (maskY &lt;= 0) { maskY = 0; } else if (maskY &gt;= maskMax) { maskY = maskMax; } mask.style.left = maskX + 'px'; mask.style.top = maskY + 'px'; // 3. 遮罩层的移动和大图片的移动成比例： // 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离 var bigIMg = document.querySelector('.bigImg'); //大图片 // 大图片最大移动距离 var bigMax = bigIMg.offsetWidth - big.offsetWidth; // 大图片的移动距离 X Y var bigX = maskX * bigMax / maskMax; var bigY = maskY * bigMax / maskMax; bigIMg.style.left = -bigX + 'px'; bigIMg.style.top = -bigY + 'px'; })}) client系列使用client系列相关属性可以获取元素可视区的相关信息，动态得到该元素的边框大小，元素大小 client系列属性 作用 element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding，内容区的宽度，不含边框，返回数值不带单位 element.clientHeight 返回自身包括padding，内容区的高度，不含边框，返回数值不带单位 scroll系列使用scroll系列的相关属性可以动态的得到该元素的大小，滚动距离 scroll系列属性 作用 element.scrollTop 返回被卷去的上侧距离，返回数值不带单位 element.scrollLeft 返回被卷去的左侧距离，返回数值不带单位 element.scrollWidth 返回自身内容实际的宽度，不含边框，返回数值不带单位 element.scrollHeight 返回自身内容实际的高度，不含边框，返回数值不带单位 固定侧边栏案例 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div class=&quot;slider-bar&quot;&gt; &lt;span class=&quot;goBack&quot;&gt;返回顶部&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;header w&quot;&gt;头部区域&lt;/div&gt; &lt;div class=&quot;banner w&quot;&gt;banner区域&lt;/div&gt; &lt;div class=&quot;main w&quot;&gt;主体部分&lt;/div&gt; &lt;script&gt; //1. 获取元素 var sliderbar = document.querySelector('.slider-bar'); var banner = document.querySelector('.banner'); // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面 var bannerTop = banner.offsetTop // 当我们侧边栏固定定位之后应该变化的数值 var sliderbarTop = sliderbar.offsetTop - bannerTop; var main = document.querySelector('.main'); var goBack = document.querySelector('.goBack'); var mainTop = main.offsetTop; // 2. 页面滚动事件 scroll document.addEventListener('scroll', function() { // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位 if (window.pageYOffset &gt;= bannerTop) { //获取页面滚动大小 sliderbar.style.position = 'fixed'; sliderbar.style.top = sliderbarTop + 'px'; } else { sliderbar.style.position = 'absolute'; sliderbar.style.top = '300px'; } // 4. 当我们页面滚动到main盒子，就显示 goback模块 if (window.pageYOffset &gt;= mainTop) { goBack.style.display = 'block'; } else { goBack.style.display = 'none'; } }) &lt;/script&gt;&lt;/body&gt; 三大系列总结 三大系列大小对比 作用 element.offsetWidth 返回自身包括padding，边框，内容区的宽度 element.clientWidth 返回自身包括padding，内容区的宽度，不包含边框 element.scrollWidth 返回自身实际的宽度，不包含边框 主要用法 offset系列常用于获取元素位置：offsetLeft offsetTop client系列常用于获取元素大小： clientWidth clientHeight scroll系列常用于获取元素滚动距离： scrollTop scrollLeft 获取页面滚动距离通过：window.pageXOffset window.pageYOffset mouseenter和mouseover的区别当鼠标移动到元素上时就会触发mouseenter事件，类似mouseover，两者的差别是 mouseover鼠标经过自身盒子会触发，经过子盒子还会触发，mouseenter只会经过自身盒子时触发，因为mouseenter不会冒泡 与mouseenter搭配鼠标离开mouseleave同样不会冒泡 动画原理核心原理：通过定时器setInterval()不断移动盒子位置 123456789&lt;script&gt; var div = document.querySelector('div'); var timer = setInterval(function(){ if(div.offsetLeft &gt;= 300){ clearInterval(timer); } div.style.left = div.offsetLeft + 1 + 'px'; //获取当前位置并加上1个移动距离 }, 30) &lt;/script&gt; 简单的动画函数封装12345678910111213141516171819202122232425&lt;body&gt; &lt;button&gt;点击purple&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;script&gt; var div = document.querySelector('div'); var span = document.querySelector('span'); var btn = document.querySelector('button'); function animate(obj, target){ //先清除，避免连续点击按钮触发多个定时器 clearInterval(obj.timer); //给每个对象的属性添加 obj.timer = setInterval(function(){ if(obj.offsetLeft &gt; target){ clearInterval(obj.timer); } obj.style.left = obj.offsetLeft + 1 + 'px'; }, 30) } btn.addEventListener('click', function(){ animate(span, 200); }) animate(div, 300); &lt;/script&gt;&lt;/body&gt; 缓动动画的实现123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;button class=&quot;btn500&quot;&gt;点击到500&lt;/button&gt; &lt;button class=&quot;btn900&quot;&gt;点击到900&lt;/button&gt; &lt;span&gt;&lt;/span&gt; &lt;script&gt; var span = document.querySelector('span'); var btn500 = document.querySelector('.btn500'); var btn900 = document.querySelector('.btn900'); function animate(obj, target, callback){ //回调函数callback clearInterval(obj.timer); obj.timer = setInterval(function(){ //缓动动画步长 var step = (target - obj.offsetLeft) / 10; //根据正负值不同取整，能够在多个目标间移动 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if(obj.offsetLeft == target){ clearInterval(obj.timer); //定时器结束时调用回调函数 if(callback){ callback(); } } obj.style.left = obj.offsetLeft + step + 'px'; }, 15) } btn500.addEventListener('click', function(){ animate(span, 500, function(){ //传入回调函数 span.style.backgroundColor = 'skyblue'; }); }) btn900.addEventListener('click', function(){ animate(span, 900); }) &lt;/script&gt;&lt;/body&gt; 滑动条案例 12345678910111213141516171819202122//引入animate.js的缓动动画函数&lt;body&gt; &lt;div class=&quot;sliderbar&quot;&gt; &lt;span&gt;←&lt;/span&gt; &lt;div class=&quot;con&quot;&gt;问题反馈&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var sliderbar = document.querySelector('.sliderbar'); var con = document.querySelector('.con'); sliderbar.addEventListener('mouseenter', function() { animate(con, -160, function() { sliderbar.children[0].innerHTML = '→'; //h }); }) sliderbar.addEventListener('mouseleave', function() { animate(con, 0, function() { sliderbar.children[0].innerHTML = '←'; }); }) &lt;/script&gt;&lt;/body&gt; 轮播图案例 结构搭建123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div class=&quot;focus fl&quot;&gt; &lt;!-- 左侧按钮 --&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-l&quot;&gt; &amp;lt; &lt;/a&gt; &lt;!-- 右侧按钮 --&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-r&quot;&gt; &amp;gt; &lt;/a&gt; &lt;!-- 核心的滚动区域 --&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 小圆圈 --&gt; &lt;ol class=&quot;circle&quot;&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt; 功能需求 当鼠标经过轮播图时，左右按钮显示，离开时隐藏 点击小圆圈可以播放对应的图片 点击右侧按钮，图片向左播放一张，左侧按钮同理 图片播放的同时，小圆圈模块跟随一起变化 鼠标不经过轮播图，会自动播放图片，鼠标经过时，播放停止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//在页面加载完之后window.addEventListener('load', function(){ //1.当鼠标经过轮播图时显示左右两个按钮 //获得左右按钮和轮播图模块 var arrow_l = document.querySelector('.arrow-l'); var arrow_r = document.querySelector('.arrow-r'); var focus = document.querySelector('.focus'); focus.addEventListener('mouseenter', function(){ arrow_l.style.display = 'block'; arrow_r.style.display = 'block'; //鼠标离开，停止播放 clearInterval(timer); timer = null; }) focus.addEventListener('mouseleave', function(){ arrow_l.style.display = 'none'; arrow_r.style.display = 'none'; //鼠标进入，开始播放 timer = setInterval(function(){ arrow_r.click(); }, 2000); }) //2.根据图片个数动态生成小圆圈个数，点击每个圆圈，图片发生滚动 var ul = focus.querySelector('ul'); var ol = focus.querySelector('.circle') //获取轮播图大小 var focusWidth = focus.offsetWidth; for(var i = 0; i &lt; ul.children.length ; i++){ var li = document.createElement('li'); //为每个圆圈设置索引 li.setAttribute('index', i); //为每个小圆圈添加事件 li.addEventListener('click', function(){ //选中圆圈改变颜色，排他思想 for(var i = 0; i &lt; ol.children.length ; i++){ ol.children[i].className = ''; } this.className = 'current'; //通过获得索引来控制图片移动距离 var index = this.getAttribute('index'); //同时需要更改这两个值保证左右按钮的移动和点击圆圈的移动的统一 num = index; circle = index; //调用缓动动画函数实现图片的移动 animate(ul, -index * focusWidth); }) ol.appendChild(li); } ol.children[0].className = 'current'; //3.实现点击右侧按钮滚动图片，无缝滚动原理：在图片最后多复制一个第一张图片，在移动这一张图片时快速跳转到第一张，再滚动 //通过js克隆图片 var first = ul.children[0].cloneNode(true); ul.appendChild(first); //设置变量记录移动次数 var num = 0; var circle = 0; //右侧按钮点击事件 arrow_r.addEventListener('click', function(){ //达到最后一张图片时，并点击 if(num == ul.children.length - 1){ //跳转为第一张再滚动 ul.style.left = 0; num = 0; } num++; //滚动 animate(ul, -num * focusWidth); //4.实现点击右侧按钮，小圆圈同时改变 circle++; if(circle == ol.children.length){ circle = 0; } //封装的小圆圈改变函数 circleChange(); }) //左侧按钮实现，同右侧 arrow_l.addEventListener('click', function(){ //达到第一张图片时，点击 if(num == 0){ //回到最后一张再滚动 num = ul.children.length - 1; ul.style.left = -num * focusWidth + 'px'; } num--; animate(ul, -num * focusWidth); circle--; if(circle &lt; 0){ circle = ol.children.length - 1; } circleChange(); }) //封装的改变小圆圈的函数 function circleChange(){ for(var i = 0; i &lt; ol.children.length; i++){ ol.children[i].className = ''; } ol.children[circle].className = 'current'; } //5.自动播放图片定时器，图片的移动方法同点击右侧按钮 var timer = setInterval(function(){ //手动触发dia arrow_r.click(); }, 2000);}) 节流阀用来防止轮播图按钮连续点击造成播放过快，当上一个函数动画内容执行完毕，再去执行下一个动画函数，让事件无法连续点击 核心思路：利用回调函数，添加一个变量来控制 12345678910111213141516171819var flag = true; arrow_r.addEventListener('click', function(){ if(flag){ flag = false; if(num == ul.children.length - 1){ ul.style.left = 0; num = 0; } num++; animate(ul, -num * focusWidth, function(){ false = true; //设置回调函数 }); circle++; if(circle == ol.children.length){ circle = 0; } circleChange(); } }) 带有动画的返回顶部案例12345678910111213141516171819goBack.addEventListener('click',function(){ animate(0, 0); }) //修改缓动动画函数 function animate(obj, target, callback){ clearInterval(obj.timer); obj.timer = setInterval(function(){ //页面向上移动 var step = (target - window.pageYOffset) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if(window.pageYOffset == target){ clearInterval(obj.timer); if(callback){ callback(); } } window.scroll(0, window.pageYOffset + step) }, 15) 筋斗云案例 123456789101112131415161718192021&lt;script src=&quot;animate.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.addEventListener('load', function(){ var cloud = document.querySelector('.cloud'); var c_nav = document.querySelector('.c-nav'); var lis = c_nav.querySelectorAll('li'); //记录点击后的位置 var current = 0; for(var i = 0; i &lt; lis.length; i++){ lis[i].addEventListener('mouseenter', function(){ animate(cloud, this.offsetLeft); }) lis[i].addEventListener('mouseleave', function(){ animate(cloud, current); }) lis[i].addEventListener('click', function(){ current = this.offsetLeft; }) } }) &lt;/script&gt;","link":"/2022/05/19/JS-BOM%E6%8A%80%E6%9C%AF/"},{"title":"LeetCode 611. 有效三角形的个数","text":"给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例1： 1234567输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3 解题思路1.暴力​ 这道题要求枚举符合条件的三元组，最简单的方法是通过三层循环直接枚举所有的组合，对三边都进行 a+b&lt;c &amp;&amp; a+c&lt;b &amp;&amp; b+c&lt;a 的判断，累加求出个数。 2.排序+二分​ 首先我们对数组进行排序，对于已排序数组，即三元组a &lt; b &lt; c，当且仅当 a + b &gt; c时符合条件，因此我们可以通过两层循环固定a,b，对于c在有序区间中找到小于a+b的最大值，则(b,c]中的元素个数即为当前a,b对应的解个数，累加即可。 ​ 时间复杂度为 $n^2log(n)$ 12345678910111213141516171819202122232425class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; int res = 0; int left, right, mid; for(int i = 0; i &lt; n - 2; i++){ for(int j = i + 1; j &lt; n - 1; j++){ left = j + 1; right = n - 1; while(left &lt; right){ mid = (left + right + 1) / 2; if(nums[mid] &gt;= nums[i] + nums[j]){ right = mid - 1; }else{ left = mid; } } if(nums[left] &lt; nums[i] + nums[j]) res += left - j; } } return res; }} 3.排序+双指针​ 依然首先对数组排序，我们考虑a + b &gt; c的条件，我们可以先固定最长边c，通过双指针来寻找a,b。一个关键点在于反向遍历c，每一个c对应的left和right指针，left=0，right=k-1。​ 如果nums[left] + nums[right] &gt; c,则[left, right]区间的所有数符合条件，right左移；​ 如果nums[left] + nums[right] &lt;= c,则left右移，直到大于c。​ 最后left于right碰撞，即已经找完当前c对应的所有解。 ​ 时间复杂度为 $n^2$ 1234567891011121314151617181920class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; int res = 0; for(int i = n-1; i&gt;=2; i--){ int right = i-1; int left = 0; while(left &lt; right){ if(nums[left] + nums[right] &gt; nums[i]){ res += right - left; right--; }else{ left++; } } } return res; }}","link":"/2021/12/29/LeetCode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"LeetCode 658.找到K个最接近的元素","text":"给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。 返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： |a - x| &lt; |b - x| 或者|a - x| == |b - x| 且 a &lt; b 示例 1： 12输入：arr = [1,2,3,4,5], k = 4, x = 3输出：[1,2,3,4] 解题思路1.排除法（双指针）我们可以反向来思考这道题，即删去n-k个最不接近的元素，剩下的元素即为最接近的k个。 我们设置指向头尾的两个指针left，right，每次删除掉相差更远的元素，对应指针向内缩减。 时间复杂度为$O(n)$ 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) { int n = arr.length; int left = 0; int right = n - 1; int removeNum = n - k; while(removeNum-- &gt; 0){ if(x - arr[left] &lt;= arr[right] - x){ right--; }else{ left++; } } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; k; i++){ list.add(arr[left + i]); } return list; }} 这里两数之差的比较没有采用绝对值，而是x - arr[left] &lt;= arr[right] - x，一种比较容易理解的方法是 x &lt;= (arr[left] + arr[right]) / 2; 2.二分查找我们要找最接近的k个数，当我们找到最优区间的最左边的那个数时，问题也相应解决。 这最优区间的最左边的数只会存在于区间 [0， n - k]。就可以通过二分查找在这区间中找到答案，设这个值为target。 令left = 0， right=n-k，二分mid=（left + right）/ 2, 二分的手段可以认为是一种随机选取，目的是通过二分可以快速排除不可能存在target的区间。 关键在于每次的判断条件，我们考虑 [mid, mid+k]这个k+1的区间，因为是k+1个数，我们必能够排除一个相对于x更远的数，同解法一类似，若arr[mid + k]与x更接近，则删除最左端也就是mid所指的数，因此mid及mid左边的数不可能是最优左边界（target），令left = mid + 1; 相反,则要删除最右端的数，导致的结果是mid的右边都不可能是target，令right = mid。通过这种判断手段，来在可能区间中定位target。 时间复杂度$O(logn + k)$ 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) { int n = arr.length; int left = 0; int right = n - k; int mid; while(left &lt; right){ mid = (left + right) /2; if(x - arr[mid] &gt; arr[mid + k] - x){ left = mid + 1; }else{ right = mid; } } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i&lt; k; i++){ list.add(arr[left + i]); } return list; }}","link":"/2021/12/29/LeetCode-658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/"},{"title":"LeetCode7-53","text":"LeetCode07 整数反转 LeetCode53 最大子序和 leetcode7 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 1234567891011121314class Solution {public: int reverse(int x) { int result = 0; while(x != 0){ if(result &gt; INT_MAX / 10 || result &lt; INT_MIN / 10) return 0; int a = x % 10; x /= 10; result = result * 10 + a; } return result; } }; 这道题的算法思想为通过数学的方法，模拟数字的弹出和推入，关键点在于溢出的检测。 2^31-1=2147483647 -2^31=-2147483648 我们要保证返回的result不会溢出，就要在数字推入result前检测，方法为 1if(result &gt; INT_MAX / 10 || result &lt; INT_MIN / 10) 不能使用result * 10 &lt; INT_MAX. 这条语句同时也保证了推入数字a时也不会溢出，因为若要溢出，原数据x为10位数并且也小于INT_MAX，则最后推入的数字一定小于等于2，不会大于7而导致溢出，小于零时同理。 复杂度分析 时间复杂度：O(log |x|)。翻转的次数即 x十进制的位数 leetcode53 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 1234567891011class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int pre = 0, maxAns = nums[0]; for (int i = 0; i &lt; nums.size(); i++) { pre = max(pre + nums[i], nums[i]); maxAns = max(maxAns, pre); } return maxAns; }}; 动态规划 我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的…但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的 为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」 定义状态（定义子问题）dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。 状态转移方程$$dp[i]=\\begin{cases}dp[i-1]+nums[i],dp[i-1]&gt;0\\nums[i],dp[i-1]\\le0\\end{cases}$$ 还可以写成这样 $dp[i] = max{dp[i-1]+nums[i],,,,nums[i]}$ 输出把所有的 dp[0]、dp[1]、……、dp[n - 1] 都看一遍，取最大值 优化空间dp[i] 的值只与dp[i-1]有关，可以只使用一个变量来维护dp[i-1], 空间复杂度优化到O(1)。","link":"/2021/09/12/LeetCode7-53/"},{"title":"JS 高级","text":"JS 高级 基础总结深入数据类型分类 基本（值）类型 String：任意字符串 Number：任意的数字 Boolean：true false Undefined：undefined Null：null 对象（引用）类型 Object：任意对象 Function：一种特别对象（可以执行） Array：一种特别的对象（数值下标，内部数据有序） 判断 ===： 判等判断 可以判断：undefined， null typeof: 返回数据类型的字符串表达 可以判断：undefined / number / string / true/false / function 不能判断：null与object object与array 1234567891011var aconsole.log(a, typeof a, typeof a==='undefined',a===undefined ) // undefined 'undefined' // true trueconsole.log(undefined==='undefined') //falsea = 4console.log(typeof a==='number')a = 'atguigu'console.log(typeof a==='string')a = trueconsole.log(typeof a==='boolean')a = nullconsole.log(typeof a, a===null) // 'object' instanceof:判断对象的具体类型 12345678910111213141516171819 var b1 = { b2: [1, 'abc', console.log], b3: function () { console.log('b3') return function () { return 'xfzhang' } } } console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true trueconsole.log(typeof b1.b2) // 'object' typeof数组返回'object'console.log(typeof b1.b3==='function') // true b1.b2[2](4)console.log(b1.b3()()) 几个问题 undefined 与 null 的区别 undefined代表定义未赋值 null定义并赋值了, 只是值为null 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 123456//起始var b = null // 初始赋值为null, 表明将要赋值为对象//确定对象就赋值b = ['atguigu', 12]//最后b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型 数据类型：基本类型/对象类型 变量类型： 基本类型：保存就是基本类型的数据 引用类型：保存的是地址值 数据变量内存 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 123456789var obj1 = {name: 'Tom'}var obj2 = obj1obj2.age = 12console.log(obj1.age) // 12function fn (obj) { obj.name = 'A'}fn(obj1)console.log(obj2.name) //A ​ 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 123456789101112var a = {age: 12}var b = aa = {name: 'BOB', age: 13}b.age = 14console.log(b.age, a.name, a.age) // 14 Bob 13function fn2 (obj) { obj = {age: 15}}fn2(a)console.log(a.age) // 13 对象释放内存 ​ 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 对象对象的组成 属性: 属性名(字符串)和属性值(任意)组成 ​ 方法: 一种特别的属性(属性值是函数) 访问对象内部数据 .属性名: 编码简单, 有时不能用 [‘属性名’]: 编码麻烦, 能通用 *必须使用[‘属性名’]的方式 属性名包含特殊字符: - ， 空格 属性名不确定 12345678910111213var p = {}//1. 给p对象添加一个属性: content type: text/json// p.content-type = 'text/json' //不能用p['content-type'] = 'text/json'console.log(p['content-type'])//2. 属性名不确定var propName = 'myAge'var value = 18// p.propName = value //不能用p[propName] = valueconsole.log(p[propName]) 函数定义函数123456function fn1 () { //函数声明 console.log('fn1()')}var fn2 = function () { //表达式 console.log('fn2()')} 函数调用 test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 12345678var obj = {}function test2 () { this.xxx = 'atguigu'} // obj.test2() 不能直接, 根本就没有 test2.call(obj) // obj.test2() // 可以让一个函数成为指定任意对象的方法进行调用 console.log(obj.xxx) 回调函数 什么函数才是回调函数? 你定义的 你没有调 但最终它执行了(在某个时刻或某个条件下) 常见的回调函数? dom事件回调函数 ==&gt;发生事件的dom元素 定时器回调函数 ===&gt;window ajax请求回调函数 生命周期回调函数 IIFE全称: Immediately-Invoked Function Expression 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 123456789101112131415161718192021(function () { //匿名函数自调用 var a = 3 console.log(a + 3) })() var a = 4 console.log(a) ;(function () { var a = 1 function test () { console.log(++a) } window.$ = function () { // 向外暴露一个全局函数 return { test: test } } })() $().test() // 1. $是一个函数 2. $执行后返回的是一个对象 函数中的this this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 test.call(obj): obj 123456789101112131415161718192021222324252627282930313233function Person(color) { console.log(this) this.color = color; this.getColor = function () { console.log(this) return this.color; }; this.setColor = function (color) { console.log(this) this.color = color; }; } Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = {}; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() { function fun2() { console.log(this); } fun2(); //this是谁? window } fun1(); 函数高级原型和原型链原型prototype函数的prototype属性 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) 这个原型对象中有一个属性constructor, 它指回这个函数对象 给（一般是构造函数的）原型对象添加属性(一般都是方法) 作用: 函数的所有实例对象自动拥有原型中的属性(方法) 1234567891011121314151617// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype) //object 'object'function Fun () {//alt + shift +r(重命名rename)}console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () { console.log('test()')}var fun = new Fun()fun.test() 显式原型和隐式原型 每个函数function都有一个prototype，即显式原型(属性) 每个实例对象都有一个__proto__，可称为隐式原型(属性) 对象的隐式原型的值为其对应构造函数的显式原型的值 总结: 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前) 123456789101112//1.定义构造函数function Fn() { // 内部语句: this.prototype = {}}//2.创建实例对象var fn = new Fn() // 内部语句: this.__proto__ = Fn.prototype//3.给原型添加方法Fn.prototype.test = function () { console.log('test()')}//4.通过实例调用原型的方法fn.test() 原型链 访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着__proto__这条链向上查找, 找到返回 如果最终没找到, 返回undefined 别名: 隐式原型链 作用: 查找对象的属性(方法) 深入理解原型 1. 12var o1 = {}var o1 = new Object() ​ 直接创建对象时，obj这个对象本质上是被Object函数创建的，因此obj.__proto__=== Object.prototype，即，每个对象都有一个proto属性，指向创建该对象的函数的prototype ```jsvar f1 = new Foo() 12345678 {% asset_img 1780825-20190829182201479-1238403745.png 1780825-20190829182201479-1238403745 %} 当通过自定义函数创建对象时，对象的\\_\\_proto\\_\\_指向这个函数的原型，而自定义函数的prototype本质上就是一个空对象，都是被Object创建，所以它的\\_\\_proto\\_\\_指向的就是Object.prototype。**但是，Object.prototype确实一个特例——它的\\_\\_proto\\_\\_指向的是null**3. ```js function foo(x, y){return x+y} var foo = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x+y&quot;) 函数也是一种对象，函数也有__proto__属性，每个函数都是Function的实例对象，包括Object函数，所以自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype。但是，这里Function.__proto__指向Function.prototype，原因是：Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以Function是被自身创建的。所以它的__proto__指向了自身的Prototype ​ Function.prototype指向的对象也是一个普通的被Object创建的对象，它的__proto__是不是也指向Object.prototype 完整的关系如下 ​ 几个问题 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足) 123console.log(Fn.prototype instanceof Object) // true console.log(Object.prototype instanceof Object) // false console.log(Function.prototype instanceof Object) // true 所有函数都是Function的实例(包含Function) 1console.log(Function.__proto__===Function.prototype) Object的原型对象是原型链尽头 1console.log(Object.prototype.__proto__) // null 原型的属性 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 instanceofinstanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false 12345678910111213function Foo() { }var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // trueconsole.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() {}console.log(Object instanceof Foo) // false 执行上下文与执行上下文栈变量提升和函数提升在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分，js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升。 变量提升的本质其实是由于js引擎在编译的时候，就将所有的变量声明了，因此在执行的时候，所有的变量都已经完成声明。 当有多个同名变量声明的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则是由最后的一个函数声明覆盖之前所有的声明 执行上下文 代码分类(位置) 全局代码 函数(局部)代码 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值, 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中) 对局部数据进行预处理 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 函数在定义的时候（不是调用的时候），就已经确定了函数体内部变量的作用域。 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 作用域和作用域链 分类 全局作用域 函数作用域 没有块作用域(ES6有了) 作用 隔离变量，不同作用域下同名变量不会有冲突 作用域链 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则(自由变量跨作用域取值时，要去创建这个函数的作用域取值) 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包 闭包到底是什么? 使用chrome调试查看 理解一: 闭包是嵌套的内部函数(绝大部分人) 理解二: 包含被引用变量(函数)的对象(极少数人) 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件? 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 123456789function fn1 () { var a = 2 var b = 'abc' function fn2 () { //执行函数定义就会产生闭包(不用调用内部函数) console.log(a) } // fn2() } fn1() 常见的闭包 将函数作为另一个函数的返回值 1234567891011function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 将函数作为实参传递给另一个函数调用 123456function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000) 闭包的作用 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 12345678910111213141516function fn1() { var a = 2 function fn2() { a++ console.log(a) // return a } function fn3() { a-- console.log(a) } return fn3}var f = fn1()f() // 1f() // 0 闭包的生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 自定义JS模块JS模块： 具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包含n个方法的对象或函数 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能 123456789101112131415161718function myModule() { //私有数据 var msg = 'My atguigu' //操作数据的函数 function doSomething() { console.log('doSomething() '+msg.toUpperCase()) } function doOtherthing () { console.log('doOtherthing() '+msg.toLowerCase()) } //向外暴露对象(给外部使用的方法) return { doSomething: doSomething, doOtherthing: doOtherthing }} 1234567891011121314151617(function () { //私有数据 var msg = 'My atguigu' //操作数据的函数 function doSomething() { console.log('doSomething() '+msg.toUpperCase()) } function doOtherthing () { console.log('doOtherthing() '+msg.toLowerCase()) } //向外暴露对象(给外部使用的方法) window.myModule2 = { doSomething: doSomething, doOtherthing: doOtherthing }})() 闭包的缺点 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长 容易造成内存泄露 解决 能不用闭包就不用 及时释放 1234567891011function fn1() { var arr = new Array[100000] function fn2() { console.log(arr.length) } return fn2}var f = fn1()f()f = null //让内部函数成为垃圾对象--&gt;回收闭包 对象高级创建对象 Object构造函数模式 123456789// 先创建空Object对象var p = new Object()p = {} //此时内部数据是不确定的// 再动态添加属性/方法p.name = 'Tom'p.age = 12p.setName = function (name) { this.name = name} 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 对象字面量模式 1234567var p = { name: 'Tom', age: 12, setName: function (name) { this.name = name }} 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 工厂模式 123456789101112131415function createPerson(name, age) { //返回一个对象的函数===&gt;工厂函数 var obj = { name: name, age: age, setName: function (name) { this.name = name } } return obj}// 创建2个人var p1 = createPerson('Tom', 12)var p2 = createPerson('Bob', 13) 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 自定义构造函数模式 12345678function Person(name, age) { this.name = name this.age = age this.setName = function (name) { this.name = name }}var p1 = new Person('Tom', 12) 套路: 自定义构造函数, 通过new创建对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 构造函数+原型的组合模式 123456789function Person(name, age) { //在构造函数中只初始化一般属性 this.name = name this.age = age}Person.prototype.setName = function (name) { this.name = name}var p1 = new Person('Tom', 23) 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 继承模式 原型链继承 子类型的原型为父类型的一个实例对象 1234567891011121314151617181920212223242526//父类型function Supper() { this.supProp = 'Supper property'}Supper.prototype.showSupperProp = function () { console.log(this.supProp)}//子类型function Sub() { this.subProp = 'Sub property'}// 子类型的原型为父类型的一个实例对象Sub.prototype = new Supper()// 让子类型的原型的constructor指向子类型Sub.prototype.constructor = SubSub.prototype.showSubProp = function () { console.log(this.subProp)}var sub = new Sub()sub.showSupperProp()// sub.toString()sub.showSubProp()console.log(sub) // Sub ​ 2.借用构造函数继承(没有真正继承) ​ 在子类型构造函数中通用call()调用父类型构造函数 12345678910111213function Person(name, age) { this.name = name this.age = age}function Student(name, age, price) { Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price}var s = new Student('Tom', 20, 14000)console.log(s.name, s.age, s.price) 原型链+借用构造函数的组合继承 利用原型链实现对父类型对象的方法继承 * 利用call()借用父类型构建函数初始化相同属性 1234567891011121314151617181920212223function Person(name, age) { this.name = name this.age = age}Person.prototype.setName = function (name) { this.name = name}function Student(name, age, price) { Person.call(this, name, age) // 为了得到属性 this.price = price}Student.prototype = new Person() // 为了能看到父类型的方法Student.prototype.constructor = Student //修正constructor属性Student.prototype.setPrice = function (price) { this.price = price}var s = new Student('Tom', 24, 15000)s.setName('Bob')s.setPrice(16000)console.log(s.name, s.age, s.price) 线程机制和事件机制浏览器内核 内核由很多模块组成 js引擎模块：复制js程序的编译和运行 html,css文档解析模块 : 负责页面文本的解析 dom/css模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制 定时器模块 : 负责定时器的管理 网络请求模块 : 负责服务器请求(常规/Ajax) 事件响应模块 : 负责事件的管理 事件循环模型 所有代码分类 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码(异步代码): 处理回调逻辑 js引擎执行代码的基本流程: 初始化代码===&gt;回调代码 模型的2个重要组成部分: 事件(定时器/DOM事件/Ajax)管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行","link":"/2022/06/25/JS-%E9%AB%98%E7%BA%A7/"},{"title":"JS DOM技术","text":"DOM技术DOM简介文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口 W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式 文档：一个页面就是一个文档，DOM中使用doucument来表示 元素：页面中的所有标签都是元素，DOM中使用 element 表示 节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示 DOM 把以上内容都看做是对象 获取元素获取页面元素DOM在我们实际开发中主要用来操作元素。 获取页面中的元素可以使用以下几种方式: 根据 ID 获取 根据标签名获取 通过 HTML5 新增的方法获取 特殊元素获取 根据ID获取使用 getElementByld() 方法可以获取带ID的元素对象 1doucument.getElementByld('id名') 使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。 123456789101112&lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;&lt;script&gt; // 1.因为我们文档页面从上往下加载，所以得先有标签，所以script写在标签下面 // 2.get 获得 element 元素 by 通过 驼峰命名法 // 3.参数 id是大小写敏感的字符串 // 4.返回的是一个元素对象 var timer = document.getElementById('time'); console.log(timer); // 5. console.dir 打印我们的元素对象，更好的查看里面的属性和方法 console.dir(timer);&lt;/script&gt; 根据标签名获取根据标签名获取，使用 getElementByTagName() 方法可以返回带有指定标签名的对象的集合 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历 得到元素对象是动态的 返回的是获取过来元素对象的集合，以伪数组的形式存储 如果获取不到元素，则返回为空的伪数组(因为获取不到对象) 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1.返回的是获取过来元素对象的集合 以伪数组的形式存储 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 2.依次打印,遍历 for (var i = 0; i &lt; lis.length; i++) { console.log(lis[i]); } // 3.如果页面中只有 1 个 li，返回的还是伪数组的形式 // 4.如果页面中没有这个元素，返回的是空伪数组&lt;/script&gt; 还可以根据标签名获取某个元素（父元素）内部所有指定标签名的子元素,获取的时候不包括父元素自己 12345&lt;script&gt; //element.getElementsByTagName('标签名'); 父元素必须是指定的单个元素 var ol = document.getElementById('ol'); console.log(ol.getElementsByTagName('li'));&lt;/script&gt; H5新增方法获取根据类名获取根据类名获取，使用 getElementByClassName() 方法可以返回带有指定类名的对象的集合 1document.getElementsByClassName('类名'); 根据指定选择器获取根据指定选择器获取，使用 querySelector()方法返回第一个元素对象 使用 querySelectorAll()方法获取指定选择器返回的所有元素对象 123456document.querySelector('选择器');// 切记里面的选择器需要加符号 // 类选择器.box // id选择器 #navvar firstBox = document.querySelector('.box'); 获取特殊元素返回body元素对象 1document.body; 返回html元素对象 1document.documentElement; 事件基础事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发— 响应机制。 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。 事件三要素 事件源(谁) 事件类型(什么事件) 事件处理程序(做啥) 123456789101112&lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件是有三部分组成 事件源 事件类型 事件处理程序 我们也称为事件三要素 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById('btn'); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() { alert('点秋香'); }&lt;/script&gt; 事件执行步骤 获取事件源 注册事件(绑定事件) 添加事件处理程序(采取函数赋值形式) 12345678910111213&lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector('div'); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() { console.log('我被选中了'); }&lt;/script&gt; 鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 操作元素JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性 改变元素内容 element.innerText: 从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉(不识别HTML标签) element.innerHTML: 起始位置到终止位置的全部内容，包括HTML标签，同时保留空格和换行(识别HTML标签) 改变元素属性12345678// img.属性img.src = &quot;xxx&quot;;input.value = &quot;xxx&quot;;input.type = &quot;xxx&quot;;input.checked = &quot;xxx&quot;;input.selected = true / false;input.disabled = true / false; 改变样式属性通过 JS 修改元素的大小、颜色、位置等样式。 123// element.stylediv.style.backgroundColor = 'pink';div.style.width = '250px'; 1element.className = 'xxx'; JS里面的样式采取驼峰命名法，比如 fontSize ，backgroundColor JS 修改 style 样式操作 ，产生的是行内样式，CSS权重比较高 如果样式修改较多，可以采取操作类名方式更改元素样式 class 因为是个保留字，因此使用className来操作元素类名属性 className 会直接更改元素的类名，会覆盖原先的类名 排他思想 如果有同一组元素，我们相要某一个元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式（干掉其他人） 给当前元素设置样式 （留下我自己） 注意顺序不能颠倒，首先干掉其他人，再设置自己 12345678910111213141516171819202122232425&lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;script&gt; // 1. 获取所有按钮元素 var btns = document.getElementsByTagName('button'); // btns得到的是伪数组 里面的每一个元素 btns[i] for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { // (1) 我们先把所有的按钮背景颜色去掉 干掉所有人 for (var i = 0; i &lt; btns.length; i++) { btns[i].style.backgroundColor = ''; } // (2) 然后才让当前的元素背景颜色为pink 留下我自己 this.style.backgroundColor = 'pink'; } } //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想 &lt;/script&gt;&lt;/body&gt; 自定义属性获取属性值element.属性：获取内置属性值(元素本身自带的属性) element.getAttribute('属性')：获取自定义属性值 设置属性值element.属性 = '值'：设置内置属性值 element.setAttribute('属性', '值')：设置自定义属性值 移除属性 element.removeAttribute('属性') H5自定义属性H5规定自定义属性 data-开头作为属性名并赋值 123&lt;div data-index = &quot;1&quot;&gt;&lt;/&gt;// 或者使用JavaScript设置div.setAttribute('data-index',1); 获取H5自定义属性 兼容性获取 element.getAttribute('data-index') H5新增的：element.dataset.index 或element.dataset['index'] IE11才开始支持 节点操作获取元素通常使用两种方式： 1.利用DOM提供的方法获取元素 2.利用节点层级关系获取元素 document.getElementById() 利用父子兄节点关系获取元素 document.getElementsByTagName() 逻辑性强，但是兼容性较差 document.querySelector 等 逻辑性不强，繁琐 节点概述网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。 一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 节点类型分为三类：元素节点：nodeType 为1 、属性节点：nodeType 为2 、 文本节点：nodeType 为3(文本节点包括文字、空格、换行等） 我们在实际开发中，节点操作主要操作的是元素节点 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 父级节点 node.parentNode：可以返回某节点的父结点，注意是最近的一个父结点 如果指定的节点没有父结点则返回null 子节点 node.childNodes（标准）：返回包含指定节点的子节点的集合，该集合为即时更新的集合 返回值包含了所有的子结点，包括元素节点，文本节点等 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes node.children： 是一个只读属性，返回所有的子元素节点 它只返回子元素节点，其余节点不返回 （这个是我们重点掌握的） 第一个子节点node.firstChild ：返回第一个子节点，找不到则返回null 包含所有的节点 node.firstElementChild ：返回第一个子元素节点，找不到则返回null 有兼容性问题，IE9以上才支持 最后一个子节点 node.lastChild：返回最后一个子节点，找不到则返回null 包含所有节点 node.lastElementChild ：返回最后一个子元素节点，找不到则返回null 有兼容性问题，IE9以上才支持 考虑兼容性实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 如果想要第一个子元素节点，可以使用 node.chilren[0] 如果想要最后一个子元素节点，可以使用 node.chilren[node.chilren.length - 1] 下一个兄弟节点node.nextSibling ：返回当前元素的下一个兄弟节点，找不到则返回null 包含所有的节点 node.nextElementSibling： 返回当前元素下一个兄弟元素节点，找不到则返回null 有兼容性问题，IE9才支持 上一个兄弟节点node.previousSibling： 返回当前元素上一个兄弟节点，找不到则返回null 包含所有的节点 node.previousElementSibling 返回当前元素上一个兄弟元素节点，找不到则返回null 有兼容性问题，IE9才支持 创建节点document.createElement('tagName')： 创建由 tagName 指定的HTML 元素 因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点 添加节点node.appendChild(child) ：将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。 node.insertBefore(child, 指定元素) ：将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。 删除节点node.removeChild(child)：从 DOM 中删除一个子节点，返回删除的节点 复制节点node.cloneNode()：返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点 如果括号参数为空或者为 false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点 如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点 动态表格案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; //单元格动态生成 &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //对象数组的测试数据 var datas = [ { name: '卫英络', subject: 'javascript', score: 100 }, { name: '卫英络', subject: 'javascript', score: 100 }, { name: '卫英络', subject: 'javascript', score: 100 }, { name: '卫英络', subject: 'javascript', score: 100 } ] var tbody = document.querySelector('tbody'); for(var i = 0; i &lt; datas.length; i++){ var tr = document.createElement('tr'); tbody.appendChild(tr); for(var k in datas[i]){ var td = document.createElement('td'); td.innerHTML = datas[i][k]; tr.appendChild(td); } var td = document.createElement('td'); td.innerHTML='&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;' tr.appendChild(td); } var as = document.querySelectorAll('a'); for(var i = 0; i &lt; as.length; i++){ as[i].onclick = function(){ tbody.removeChild(this.parentNode.parentNode); } } &lt;/script&gt;&lt;/body&gt; 三种动态创建元素的区别 doucument.write()：是直接将内容写入页面的内容流，但是文档流执行完毕（页面加载完毕），再执行这个方法会导致页面全部重绘 element.innerHTML：是将内容写入某个 DOM 节点，创建多个元素效率更高（不采用直接拼接字符串，提前使用数组存放内容，再一次写入 12345var arr = [];for (var i = 0; i &lt;= 100; i++) { arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;');}inner.innerHTML = arr.join(''); document.createElement()：创建多个元素效率稍低一点点，但是结构更清晰 事件高级注册事件给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：传统方式和方法监听注册方式 传统注册方式： 利用 on 开头的事件 onclick btn.onclick = function() {} 特点：注册事件的唯一性，同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式： w3c 标准推荐方式 addEventListener() 它是一个方法 IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替（不使用） 特点：同一个元素同一个事件可以注册多个监听器，按注册顺序依次执行 事件监听eventTarget.addEventListener(type,listener[,useCapture]) 该方法接收三个参数： type:事件类型字符串，比如click,mouseover,注意这里不要带on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;button&gt;传统注册事件&lt;/button&gt; &lt;button&gt;方法监听注册事件&lt;/button&gt; &lt;button&gt;ie9 attachEvent&lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll('button'); // 1. 传统方式注册事件 btns[0].onclick = function() { alert('hi'); } btns[0].onclick = function() { alert('hao a u'); } // 2.方法监听方式 btns[1].addEventListener('click', function() { alert(22); }) btns[1].addEventListener('click', function() { alert(33); }) // 3. attachEvent ie9以前的版本支持 btns[2].attachEvent('onclick', function() { alert(11); }) &lt;/script&gt;&lt;/body&gt; 删除事件传统删除方式eventTarget.onclick = null; removeEventListener删除事件eventTarget.removeEventListener(type,listener[,useCapture]); 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; var divs = document.querySelectorAll('div'); divs[0].onclick = function() { alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; } // 2.removeEventListener 删除事件 divs[1].addEventListener('click',fn); //里面的fn不需要调用加小括号 //注意这里不能使用匿名函数 function fn(){ alert(22); divs[1].removeEventListener('click',fn); } // 3.IE9 中的删除事件方式 divs[2].attachEvent('onclick',fn1); function fn1() { alert(33); divs[2].detachEvent('onclick',fn1); } &lt;/script&gt;&lt;/body&gt; DOM事件流简介 事件流描述的是从页面中接收事件的顺序 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流 捕获阶段12345678910111213141516&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, true); &lt;/script&gt;&lt;/body&gt; 冒泡阶段123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, false); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, false); document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt;&lt;/body&gt; JS 代码中只能执行捕获或者冒泡其中的一个阶段 onclick 和 attachEvent只能得到冒泡阶段 addEventListener(type,listener[,useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false),表示在事件冒泡阶段调用事件处理程序 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 事件对象 event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面 这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去 当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数） 123456789101112131415&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); ul.addEventListener('click',function(e){ console.log(this); //this是绑定事件的元素 console.log(e.currentTarget); //指定绑定事件的元素，同this console.log(e.target); //事件触发的元素，li }) &lt;/script&gt;&lt;/body&gt; 事件对象属性方法 说明 e.target 返回触发事件的对象 标准 e.srcElement 返回触发事件的对象 非标准 ie6-8使用 e.type 返回事件的类型 比如click mouseover 不带on e.cancelBubble 该属性阻止冒泡，非标准，ie6-8使用 e.returnValue 该属性阻止默认行为 非标准，ie6-8使用 e.preventDefault() 该方法阻止默认行为 标准 比如不让链接跳转 e.stopPropagation() 阻止冒泡 标准 阻止对象默认行为12345678910111213&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;script&gt; var a = document.querySelector('a'); a.addEventListener('click', function(e){ console.log(e.type); e.preventDefault(); }) a.onclick = function(e){ //e.returnValue; //ie678 return false; //没有兼容性问题，只能在传统中用 } &lt;/script&gt; 阻止事件冒泡事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点 e.stopPropagation() 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); son.addEventListener('click', function(e) { alert('son'); e.stopPropagation(); // 阻止冒泡 dom 推荐的标准 stopPropagation() e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 }, false); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, false); document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt;&lt;/body&gt; 事件委托 事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点 1234567891011121314&lt;body&gt; &lt;ul&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { e.target.style.backgroundColor = 'pink'; }) &lt;/script&gt;&lt;/body&gt; 常见的鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 禁止鼠标右键和鼠标选中 contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单 selectstart 禁止鼠标选中 12345678910111213&lt;body&gt; &lt;h1&gt;我是一段不愿意分享的文字&lt;/h1&gt; &lt;script&gt; document.addEventListener('contextmenu', function(e) { e.preventDefault(); // 阻止默认行为 }) document.addEventListener('selectstart', function(e) { e.preventDefault(); }) &lt;/script&gt;&lt;/body&gt; 鼠标事件对象 常用鼠标事件对象 说明 e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标 e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标 e.pageX（重点） 返回鼠标相对于文档页面的X坐标 IE9+ 支持 e.pageY（重点） 返回鼠标相对于文档页面的Y坐标 IE9+ 支持 e.screenX 返回鼠标相对于电脑屏幕的X坐标 e.screenY 返回鼠标相对于电脑屏幕的Y坐标 常用键盘事件 键盘事件 触发条件 onkeyup 某个键盘按键被松开时触发 onkeydown 某个键盘按键被按下时触发 onkeypress 某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl shift 箭头等 三个事件的执行顺序是：keydown - keypress - keyup 键盘对象属性e.keyCode: 返回该键的ASCII值（已弃用） onkeydown和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写","link":"/2022/04/30/JS-DOM%E6%8A%80%E6%9C%AF/"},{"title":"element-plus引入在TypeScript5.0下的报错","text":"在最新vite基于typescript5.0环境下引入element-plus 测试环境1234&quot;element-plus&quot;: &quot;^2.3.4&quot;,&quot;typescript&quot;: &quot;~5.0.4&quot;,&quot;@vue/tsconfig&quot;: &quot;^0.3.2&quot;,&quot;vite&quot;: &quot;^4.3.4&quot;, 问题描述问题一在目前最新的vite中构建Vue项目时，使用element-plus库，使用官网推荐按需自动导入方式，在ts代码中使用 import { ElForm } from 'element-plus'类似语句导入组件时报错 模块“element-plus”没有导出的成员“ElForm”。你是想改用“import ElForm from ‘element-plus’”吗 问题二使用element-plus官网的全局导入方式，在tsconfig.json中使用以下配置获得Volar支持时报错 1234567// tsconfig.json{ &quot;compilerOptions&quot;: { // ... &quot;types&quot;: [&quot;element-plus/global&quot;] }} 找不到“element-plus/global”的类型定义文件。 程序包含该文件是因为: 在 compilerOptions 中指定的类型库 “element-plus/global” 的入口点。 错误原因typescript5.0版本升级，使用compilerOptions.moduleResolution: &quot;bundler&quot;的模块编译选项。具体参见issue 解决方法 可以回退typescript版本，例如在以下版本中不会报错 12&quot;@vue/tsconfig&quot;: &quot;0.1.3&quot;, &quot;typescript&quot;: &quot;4.9.5&quot;, 在tsconfig.json中重写moduleResolution 12345{ &quot;compilerOptions&quot;: { &quot;moduleResolution&quot;: &quot;node&quot; }}","link":"/2023/05/18/element-plus%E5%BC%95%E5%85%A5%E5%9C%A8TypeScript5-0%E4%B8%8B%E7%9A%84%E6%8A%A5%E9%94%99/"},{"title":"数据结构和算法：双指针技巧","text":"双指针技巧，常用于数组和链表此类数据结构中，通过前后指针和快慢指针在单次遍历或少次遍历中求解问题 数组数组可以双向操作，双指针可前后遍历或同向遍历 167.两数之和Ⅱ-输入有序数组 easy： 给定一个已按照 非递减顺序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 。 使用双指针，分别从数组头尾遍历，若和小于目标值，则左指针右移，若大于目标值，则右指针左移。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int hi = numbers.size() - 1; int lo = 0; while(lo &lt; hi) { if(numbers[lo] + numbers[hi] == target) { return {lo + 1, hi + 1}; }else if(numbers[lo] + numbers[hi] &lt; target) { lo++; }else{ hi--; } } return {}; }}; 209.长度最小的子数组medium： 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 。 滑动窗口：定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和 初始状态下，start 和 end 都指向下标 0 ，sum 的值为 0。 每一轮迭代，将 nums[end] 加到 sum，如果 sum ≥ s，则更新子数组的最小长度，然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum &lt; s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int hi = numbers.size() - 1; int lo = 0; while(lo &lt; hi) { if(numbers[lo] + numbers[hi] == target) { return {lo + 1, hi + 1}; }else if(numbers[lo] + numbers[hi] &lt; target) { lo++; }else{ hi--; } } return {}; }}; 链表这里提到的链表都为单链表，因此常用同向的快慢指针 141.环形链表 easy: 给定一个链表，判断链表中是否有环，如果链表中存在环，则返回 true 。 否则，返回 false .快慢指针：涉及「Floyd 判圈算法」（又称龟兔赛跑算法） ​ 定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { if(head==nullptr || head-&gt;next==nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&gt;next; while(slow!=fast) { if(fast==nullptr || fast-&gt;next == nullptr) { return false; } fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } return true; }}; 142.环形链表Ⅱ medium：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null 快慢指针：定义两个指针fast和slow，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步，fast指针走过链表末端，说明链表无环； 当fast == slow时， 两指针在环中第一次相遇，设环长为b, 去掉环链长为a, 根据： ​ f = 2s （快指针每次2步，路程刚好2倍） ​ f = s + nb (相遇时，刚好多走了n圈） 推出：s = nb 从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。 如何知道slow刚好走了a步, 可以让一指针从head开始，和slow指针一起走，则相遇时刚好就是a步。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(!(fast == nullptr || fast-&gt;next == nullptr)){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast==slow){ fast = head; while(fast!=slow){ fast=fast-&gt;next; slow=slow-&gt;next; } return slow; } } return nullptr; }}; 160.相交链表 easy: 给你两个单链表的头节点 headA和headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 双指针：无论两链表是否相交，只需要将链表LA和链表LB的链尾对齐，然后从后向前依次比较节点是否相同即可。1.从后向前访问的第一节点既不是公共节点则两链表不相交。2.从后向前访问的公共节点中最后访问的公共节点则为两链表相交的第一个节点 因为单链表无法向前遍历节点，但是可以将LA+LB和LB+LA的两条轨道拼接起来，此时尾部对齐，从前往后遍历就能找到公共节点 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA==nullptr || headB==nullptr){ return nullptr; } ListNode* pA = headA; ListNode* pB = headB; while(pA != pB) { pA = pA == nullptr ? headB : pA-&gt;next; pB = pB == nullptr ? headA : pB-&gt;next; } return pA; }};","link":"/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"},{"title":"优雅地封装Axios库","text":"在项目中对axios进行二次封装，实现更多的请求响应拦截功能 使用类进行封装我们可以创建一个自己的请求类，使用axios.create()创建axios实例作为属性，在这个instance上面可以直接添加拦截器，这和原先没有封装的axios一样。 123456789101112131415161718192021import axios from 'axios'import type { AxiosInstance } from 'axios'class MYRequest { instance: AxiosInstance this.instance.interceptors.request.use( (config) =&gt; { return config }, (err) =&gt; { return err } ) this.instance.interceptors.response.use( (res) =&gt; { return res.data }, (err) =&gt; { return err } ) 添加自己的config思路是我们可以通过这个类创建自己的实例，每个实例都可以传入自己的配置，达到不同的使用效果 123456789101112131415161718192021222324252627 interface MYRequestInterceptors { requestInterceptor?: (config: any) =&gt; any requestInterceptorCatch?: (err: any) =&gt; any responseInterceptor?: (res: any) =&gt; any responseInterceptorCatch?: (err: any) =&gt; any} interface MYRequestConfig extends AxiosRequestConfig { interceptors?: MYRequestInterceptors}class MYRequest { instance: AxiosInstance interceptors?: MYRequestInterceptors constructor(config: MYRequestConfig) { this.instance = axios.create(config) //每个实例独有的config配置拦截器 this.interceptors = config.interceptors this.instance.interceptors.request.use( this.interceptors?.requestInterceptor, this.interceptors?.requestInterceptorCatch ) this.instance.interceptors.response.use( this.interceptors?.responseInterceptor, this.interceptors?.responseInterceptorCatch ) } 为每个请求配置拦截器对于每个请求，同时也会接受相应的config配置，我们可以调用这上面传入的拦截器函数，最后返回Promise对象 12345678910111213141516171819202122232425262728class MYRequest {request&lt;T = any&gt;(config: MYRequestConfig): Promise&lt;T&gt; { //为request请求使用单独的请求拦截器 if (config.interceptors?.requestInterceptor) { config = config.interceptors.requestInterceptor(config) } return new Promise((resolve, reject) =&gt; { this.instance .request&lt;any, T&gt;(config) .then((res) =&gt; { //为request请求使用单独的响应拦截器 if (config.interceptors?.responseInterceptor) { res = config.interceptors.responseInterceptor(res) } resolve(res) }) .catch((err) =&gt; { reject(err) }) }) } get&lt;T = any&gt;(config: MYRequestConfig): Promise&lt;T&gt; { return this.request({ ...config, method: 'GET' }) }} 创建一个请求最后我们使用这个类创建一个实例，传入可选的配置项、拦截器，在这个上面添加相应的功能 12345678910111213141516const myRequest = new MYRequest({ baseURL: BASE_URL, timeout: TIME_OUT, interceptors: { requestInterceptor: (config) =&gt; { //给每个请求添加token const token = localCache.getCache(LOGIN_TOKEN) if (config.headers &amp;&amp; token) { config.headers.Authorization = `bearer ${token}` } return config } }})export default myRequest 123456export function accountLoginRequest(account: IAccount) { return myRequest.post({ url: '/login', data: account })} 至此我们完成了axios的二次封装，我们仍可以在这上面增加一些配置，如区分生产环境和开发环境的config，增加全局的请求loading等。","link":"/2023/05/03/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%B0%81%E8%A3%85Axios%E5%BA%93/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"AI算法","slug":"AI算法","link":"/tags/AI%E7%AE%97%E6%B3%95/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"axios","slug":"axios","link":"/tags/axios/"}],"categories":[{"name":"项目实践","slug":"项目实践","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}