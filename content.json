{"pages":[],"posts":[{"title":"C语言实现五子棋游戏","text":"C语言课设项目 基于C语言和EasyX图形库实现的五子棋小游戏 AI算法采用极大极小值搜索中应用Alpha-Beta剪枝 实现人机对战等功能 引言博弈算法 零和博弈，又称零和游戏或零和赛局，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有收入，其他方必有所失。 这里所提到的博弈算法适用于有完备信息的，确定性的，轮流行动的两个游戏者的零和游戏，像大多数的棋类游戏，如五子棋，象棋，围棋都满足这些条件，可以通过这套算法实现。 五子棋在今日已经被证明了是一种“不公平”的游戏，黑棋先手绝对占优，并且有先手必胜的套路。因此，五子棋发展出了各种限制黑棋的规则（如三三禁手），此类五子棋被称为“连珠”。 本文实现的五子棋为无禁手五子棋，AI算法较为简单，棋力水平达到业余水平。 界面设计此项目使用vs2019为开发工具，借助了EasyX图形库，实现较为简单的UI 程序基本结构123456789101112131415int main(){ while (1) { if (startGame() == 1) { //startGame函数为开始界面初始化 int win = game1(); //game1，game2函数分别实现人机和玩家pk gameOver1(win); } else { int win = game2(); gameOver2(win); } } return 0;} 开始页面其中涉及音乐和图片素材调用，素材文件路径可改变 涉及的EasyX图形库函数，可在EasyX文档中查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int startGame() { initgraph(600, 600); IMAGE im_start; loadimage(&amp;im_start, _T(&quot;D:\\\\素材\\\\start.jpg&quot;)); //开始界面图片 putimage(0, 0, &amp;im_start); setlinecolor(BLACK); //绘制选择按钮 setfillcolor(RGB(254, 220, 130)); fillrectangle(50, 490, 170, 545); fillrectangle(240, 490, 360, 545); fillrectangle(430, 490, 550, 545); setbkmode(TRANSPARENT); settextcolor(BLACK); LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(25, 0, _T(&quot;黑体&quot;)); outtextxy(60, 510, _T(&quot;人机对战&quot;)); outtextxy(250, 510, _T(&quot;双人游戏&quot;)); outtextxy(440, 510, _T(&quot;退出游戏&quot;)); settextstyle(&amp;nowstyle); mciSendString(_T(&quot;close stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;open D:\\\\素材\\\\background.mp3 alias bgmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play bgmusic repeat&quot;), NULL, 0, NULL); int gamemode = 0; init_tuple6type(); //调用初始化棋形函数，具体在AI算法中实现 while (1) { MOUSEMSG mouse = GetMouseMsg(); // if (mouse.x &gt;= 50 &amp;&amp; mouse.x &lt;= 170 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 1; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 240 &amp;&amp; mouse.x &lt;= 360 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 2; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 430 &amp;&amp; mouse.x &lt;= 550 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic wait&quot;), NULL, 0, NULL); exit(0); } } mciSendString(_T(&quot;close bgmusic&quot;), NULL, 0, NULL); return gamemode;} 棋盘数据 棋盘数据由结构体数组储存 12345678typedef struct node { //棋盘每个节点的数据储存 int x; //左上顶点坐标 int y; int model; //格子边框样式 int value; //是否落子（0代表无, 黑棋1, 白棋2） bool isnew; //是否显示选择框 COLORREF color; //格子颜色}NODE; 全局变量 12NODE map[15][15];COLORREF COLOR = RGB(255, 183, 111); 棋盘绘制 初始化棋盘数组中的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void initNode(){ for (int i = 75, k = 0; i &lt;= 495; i = i + 30) { for (int j = 75, g = 0; j &lt;= 495; j = j + 30) { map[k][g].x = j; map[k][g].y = i; map[k][g].value = 0; map[k][g].isnew = false; map[k][g].color = COLOR; if (k == 0 &amp;&amp; g == 0) //根据格子位置判断格子边框 { map[k][g].model = 8; } else if (k == 0 &amp;&amp; g == 14) { map[k][g].model = 7; } else if (k == 14 &amp;&amp; g == 14) { map[k][g].model = 6; } else if (k == 14 &amp;&amp; g == 0) { map[k][g].model = 5; } else if (k == 0) { map[k][g].model = 3; } else if (k == 14) { map[k][g].model = 4; } else if (g == 0) { map[k][g].model = 1; } else if (g == 14) { map[k][g].model = 2; } else if ((k == 3 &amp;&amp; g == 3) || (k == 3 &amp;&amp; g == 11) || (k == 11 &amp;&amp; g == 3) || (k == 11 &amp;&amp; g == 11) || (k == 7 &amp;&amp; g == 7)) { map[k][g].model = 9; } else { map[k][g].model = 0; } g++; } k++; } } 下棋时，棋盘会随着鼠标移动显示选择框，避免不断绘制整个棋盘导致的闪屏，于是将棋盘绘制设计为每个格子逐个绘制，在更新选择框时仅重新绘制当前位置的图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138void drawNode(NODE* node){ int x = node-&gt;x; //获得当前节点数据 int y = node-&gt;y; int model = node-&gt;model; int value = node-&gt;value; int isnew = node-&gt;isnew; COLORREF color = node-&gt;color; setfillcolor(color); solidrectangle(x, y, x + 30, y + 30); //绘制边框 setlinecolor(BLACK); switch (model) { case 0: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); break; // * // * * * // * case 3: setlinestyle(PS_SOLID, 2); line(x + 15, y + 15, x + 15, y + 30); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * * * // * // * case 4: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * // * // * * * case 1: setlinestyle(PS_SOLID, 2); line(x + 14, y + 15, x + 30, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 2: setlinestyle(PS_SOLID, 2); line(x - 1, y + 15, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 7: setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 15, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 6: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x - 1, y + 15, x + 15, y + 15); break; // * // * // * * * case 5: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x + 15, y + 15, x + 30, y + 15); break; // * // * // * * * case 8: setlinestyle(PS_SOLID, 3); line(x + 15, y + 15, x + 30, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 9: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); setfillcolor(BLACK); setlinestyle(PS_SOLID, 2); fillcircle(x + 15, y + 15, 4); break; // * // * O * // * } //绘制选择框 if (isnew) { setlinestyle(PS_SOLID, 2); setlinecolor(LIGHTGRAY); line(x + 1, y + 2, x + 8, y + 2); line(x + 2, y + 1, x + 2, y + 8); line(x + 29, y + 2, x + 22, y + 2); line(x + 29, y + 1, x + 29, y + 8); line(x + 2, y + 29, x + 8, y + 29); line(x + 2, y + 22, x + 2, y + 29); line(x + 29, y + 29, x + 22, y + 29); line(x + 29, y + 22, x + 29, y + 29); } //绘制棋子 switch (value) { case 1: setfillcolor(BLACK); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; case 2: setfillcolor(WHITE); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; }} 绘制整个棋盘函数，不断调用绘制格子函数 12345678910111213141516171819202122232425262728293031void drawBoard(){ //更新每一个节点 for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { drawNode(&amp;map[i][j]); if (map[i][j].isnew == true) { map[i][j].isnew = false; // 把上一个下棋位置的选择框清除 } } } // 绘制坐标 TCHAR strnum[19][3] = { _T(&quot;1&quot;),_T(&quot;2&quot;) ,_T(&quot;3&quot;) ,_T(&quot;4&quot;),_T(&quot;5&quot;) ,_T(&quot;6&quot;) ,_T(&quot;7&quot;),_T(&quot;8&quot;),_T(&quot;9&quot;),_T(&quot;10&quot;), _T(&quot;11&quot;),_T(&quot;12&quot;) ,_T(&quot;13&quot;) ,_T(&quot;14&quot;),_T(&quot;15&quot;) }; TCHAR strabc[19][3] = { _T(&quot;A&quot;),_T(&quot;B&quot;) ,_T(&quot;C&quot;) ,_T(&quot;D&quot;),_T(&quot;E&quot;) ,_T(&quot;F&quot;) ,_T(&quot;G&quot;),_T(&quot;H&quot;),_T(&quot;I&quot;),_T(&quot;J&quot;), _T(&quot;K&quot;),_T(&quot;L&quot;) ,_T(&quot;M&quot;) ,_T(&quot;N&quot;),_T(&quot;O&quot;) }; LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(0, 0, NULL); settextcolor(BLACK); int number = 0; for (int i = 0; i &lt; 15; i++) { outtextxy(85 + number, 60, strnum[i]); outtextxy(60, 85 + number, strabc[i]); number += 30; } } 游戏函数 game1为实现人机对战的函数，其中关于AI算法函数稍后实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int game1() { //人机对战实现 Sleep(500); setbkcolor(COLOR); cleardevice(); initNode(); drawBoard(); settextstyle(20, 10, 0, 0, 0, 1000, false, false, false); settextcolor(BLACK); settextstyle(25, 0, NULL); outtextxy(90, 530, _T(&quot;玩家执黑先行&quot;)); int whoplay = 0; int oldi = 0; //更新鼠标位置所储存的坐标 int oldj = 0; while (1) { if (whoplay == 0) { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); MOUSEMSG mouse = GetMouseMsg(); if (mouse.x &gt;= 75 &amp;&amp; mouse.y &gt;= 75 &amp;&amp; mouse.x &lt;= 525 &amp;&amp; mouse.y &lt;= 525) { //判断鼠标所处节点 int j = (mouse.x - 75) / 30; int i = (mouse.y - 75) / 30; //判断是否是空位置 if (map[i][j].value == 0) { // 如果按下了 if (mouse.mkLButton) { map[i][j].value = C_BLACK; // 下棋 map[i][j].isnew = true; //更新选择框 whoplay = 1; //轮到下一个 drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { //判断是否获胜 return win; } oldi = 0; oldj = 0; continue; } // 更新节点 map[oldi][oldj].isnew = false; drawNode(&amp;map[oldi][oldj]); map[i][j].isnew = true; drawNode(&amp;map[i][j]); oldi = i; oldj = j; } } } else { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); int board[15][15]; mapToBoard(map, board); //AI下棋 analyse(board, 4, -INT_MAX, INT_MAX); //AI算法实现函数，应用极大极小值搜索 map[decision.best.x][decision.best.y].value = C_WHITE; map[decision.best.x][decision.best.y].isnew = true; whoplay = 0; drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { return win; } oldi = 0; oldj = 0; } }} 胜负判断 每次落子后调用胜负判断函数，若有一方胜出则结束游戏 123456789101112131415161718192021222324252627282930313233343536373839404142int winner(){ int iswin = 0; int dx[4] = { 1, 0, 1, 1 }; //向四种方向搜索棋盘 int dy[4] = { 0, 1, 1, -1 }; bool isfull = true; for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { if (map[i][j].value != 0) { int nowcolor = map[i][j].value; int length[4] = { 0, 0, 0, 0 }; for (int k = 0; k &lt; 4; k++) { int nowi = i; int nowj = j; while (map[nowi][nowj].value == nowcolor &amp;&amp; nowi &gt;= 0 &amp;&amp; nowi &lt;= 14 &amp;&amp; nowj &gt;= 0 &amp;&amp; nowj &lt;= 14) { length[k]++; nowi += dx[k]; nowj += dy[k]; } } for (int k = 0; k &lt; 4; k++) { if (length[k] &gt;= 5) { if (nowcolor == C_BLACK) { iswin = 1; } else { iswin = 2; } } } } else { isfull = false; } } } if (isfull) { iswin = 3; } return iswin;} 五子棋界面设计差不多已经完成，AI下棋的算法在下一篇 C语言实现五子棋游游戏(AI算法实现)","link":"/2021/07/16/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F/"},{"title":"C语言实现五子棋游戏(AI算法实现)","text":"接上文C语言实现五子棋游戏，此文为AI算法的实现 主要为极大极小值搜索中应用Alpha-Beta剪枝 AI 算法算法思想AI算法主要思想是，电脑模拟人机双方下棋，并对落子后的局面进行评分，将分值构建成一棵树，再遍历寻找出最优解。 评估函数 首先要先实现对整个棋盘局面打分的评估函数，我设计了一个六元数组来识别五子棋的各种棋形，包括连五，活四，冲四等 然后设计一个各种棋形的权重表，用于打分，赋分有以下几个要点， 1.对于AI下棋的白棋方来说，将数值赋为正，黑棋棋形赋为负，并且相同棋形下黑棋的权重要更大，应为当AI白棋落子后即为黑子落子。 2.对于黑棋方(玩家)的连五，活四，冲四，活三等接近胜利的棋形权重要更大，同样原因是AI下完棋就到玩家下棋 3.棋形分值等级：连5&gt;活4&gt;冲4=活3&gt;眠3=活2&gt;眠2=活1，相邻等级的权重设置为相差20倍（也可以30，40倍），这是因为会重复计算等级比较低的棋型，以此避免影响总体判断。 设计各棋形的分值 123456789101112131415161718192021222324//棋子代号#define C_NONE 0#define C_BLACK 1#define C_WHITE 2//棋型代号 下标 权重#define OTHER 0//0,其他棋型不考虑#define WIN 1//100000,白赢#define LOSE 2//-10000000,黑赢#define FLEX4 3//50000,白活#define flex4 4//-80000,黑活#define BLOCK4 5//400#define block4 6//-80000#define FLEX3 7//400#define flex3 8//-8000#define BLOCK3 9//20#define block3 10//-40#define FLEX2 11//20#define flex2 12//-40#define BLOCK2 13//1#define block2 14//-2#define FLEX1 15//1#define flex1 16//-2 初始化棋形判别六元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189void init_tuple6type() { memset(tuple6type, 0, sizeof(tuple6type)); //白连5,ai赢 tuple6type[2][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][0] = WIN; tuple6type[0][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][1] = WIN; tuple6type[1][2][2][2][2][2] = WIN; tuple6type[3][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][3] = WIN; //黑连5,ai输 tuple6type[1][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][0] = LOSE; tuple6type[0][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][2] = LOSE; tuple6type[2][1][1][1][1][1] = LOSE; tuple6type[3][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][3] = LOSE; //白活4 tuple6type[0][2][2][2][2][0] = FLEX4; //黑活4 tuple6type[0][1][1][1][1][0] = flex4; //白活3 tuple6type[0][2][2][2][0][0] = FLEX3; tuple6type[0][0][2][2][2][0] = FLEX3; tuple6type[0][2][0][2][2][0] = FLEX3; tuple6type[0][2][2][0][2][0] = FLEX3; //黑活3 tuple6type[0][1][1][1][0][0] = flex3; tuple6type[0][0][1][1][1][0] = flex3; tuple6type[0][1][0][1][1][0] = flex3; tuple6type[0][1][1][0][1][0] = flex3; //白活2 tuple6type[0][2][2][0][0][0] = FLEX2; tuple6type[0][2][0][2][0][0] = FLEX2; tuple6type[0][2][0][0][2][0] = FLEX2; tuple6type[0][0][2][2][0][0] = FLEX2; tuple6type[0][0][2][0][2][0] = FLEX2; tuple6type[0][0][0][2][2][0] = FLEX2; //黑活2 tuple6type[0][1][1][0][0][0] = flex2; tuple6type[0][1][0][1][0][0] = flex2; tuple6type[0][1][0][0][1][0] = flex2; tuple6type[0][0][1][1][0][0] = flex2; tuple6type[0][0][1][0][1][0] = flex2; tuple6type[0][0][0][1][1][0] = flex2; //白活1 tuple6type[0][2][0][0][0][0] = FLEX1; tuple6type[0][0][2][0][0][0] = FLEX1; tuple6type[0][0][0][2][0][0] = FLEX1; tuple6type[0][0][0][0][2][0] = FLEX1; //黑活1 tuple6type[0][1][0][0][0][0] = flex1; tuple6type[0][0][1][0][0][0] = flex1; tuple6type[0][0][0][1][0][0] = flex1; tuple6type[0][0][0][0][1][0] = flex1; int p1, p2, p3, p4, p5, p6, x, y, ix, iy;//x:左5中黑个数,y:左5中白个数; ix:右5中黑个数,iy:右5中白个数 for (p1 = 0; p1 &lt; 4; ++p1) { for (p2 = 0; p2 &lt; 3; ++p2) { for (p3 = 0; p3 &lt; 3; ++p3) { for (p4 = 0; p4 &lt; 3; ++p4) { for (p5 = 0; p5 &lt; 3; ++p5) { for (p6 = 0; p6 &lt; 4; ++p6) { x = y = ix = iy = 0; if (p1 == 1)x++; else if (p1 == 2)y++; if (p2 == 1) { x++; ix++; } else if (p2 == 2) { y++; iy++; } if (p3 == 1) { x++; ix++; } else if (p3 == 2) { y++; iy++; } if (p4 == 1) { x++; ix++; } else if (p4 == 2) { y++; iy++; } if (p5 == 1) { x++; ix++; } else if (p5 == 2) { y++; iy++; } if (p6 == 1)ix++; else if (p6 == 2)iy++; if (p1 == 3 || p6 == 3) {//有边界 if (p1 == 3 &amp;&amp; p6 != 3) {//左边界 //白冲4 if (ix == 0 &amp;&amp; iy == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (ix == 4 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if (ix == 0 &amp;&amp; iy == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if (ix == 3 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if (ix == 0 &amp;&amp; iy == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if (ix == 2 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } else if (p6 == 3 &amp;&amp; p1 != 3) {//右边界 //白冲4 if (x == 0 &amp;&amp; y == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (x == 4 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //黑眠3 if (x == 3 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //白眠3 if (x == 0 &amp;&amp; y == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //黑眠2 if (x == 2 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //白眠2 if (x == 0 &amp;&amp; y == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } else {//无边界 //白冲4 if ((x == 0 &amp;&amp; y == 4) || (ix == 0 &amp;&amp; iy == 4)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if ((x == 4 &amp;&amp; y == 0) || (ix == 4 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if ((x == 0 &amp;&amp; y == 3) || (ix == 0 &amp;&amp; iy == 3)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if ((x == 3 &amp;&amp; y == 0) || (ix == 3 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if ((x == 0 &amp;&amp; y == 2) || (ix == 0 &amp;&amp; iy == 2)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if ((x == 2 &amp;&amp; y == 0) || (ix == 2 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } } } } } }} 基于以上的棋形分值和判别数组实现对当前棋盘的分值评估 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778EVALUATION evaluate(int(*board)[15]) { int weight[17] = { 0,1000000,-10000000,50000,-100000,400,-100000,400,-8000,20,-50,20,-50,1,-3,1,-3 };//各棋型权重 int type; int stat[4][17];//统计4个方向上每种棋型的个数 memset(stat, 0, sizeof(stat)); int STAT[17];//存在这种棋型的方向的个数 memset(STAT, 0, sizeof(STAT)); int A[17][17];//包括边界的虚拟大棋盘,3表示边界 for (int i = 0; i &lt; 17; ++i) A[i][0] = 3; for (int i = 0; i &lt; 17; ++i) A[i][16] = 3; for (int j = 0; j &lt; 17; ++j) A[0][j] = 3; for (int j = 0; j &lt; 17; ++j) A[16][j] = 3; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { A[i + 1][j + 1] = board[i][j]; } } //判断横向棋型 for (int i = 1; i &lt;= 15; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i][j + 1]][A[i][j + 2]][A[i][j + 3]][A[i][j + 4]][A[i][j + 5]]; stat[0][type]++; } } //判断竖向棋型 for (int j = 1; j &lt;= 15; ++j) { for (int i = 0; i &lt; 12; ++i) { type = tuple6type[A[i][j]][A[i + 1][j]][A[i + 2][j]][A[i + 3][j]][A[i + 4][j]][A[i + 5][j]]; stat[1][type]++; } } //判断左上至右下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i + 1][j + 1]][A[i + 2][j + 2]][A[i + 3][j + 3]][A[i + 4][j + 4]][A[i + 5][j + 5]]; stat[2][type]++; } } //判断右上至左下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 5; j &lt; 17; ++j) { type = tuple6type[A[i][j]][A[i + 1][j - 1]][A[i + 2][j - 2]][A[i + 3][j - 3]][A[i + 4][j - 4]][A[i + 5][j - 5]]; stat[3][type]++; } } EVALUATION eval;//评估结果 memset(eval.STAT, 0, sizeof(eval.STAT)); int score = 0; for (int i = 1; i &lt; 17; ++i) { score += (stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i]) * weight[i];//计分 int count = stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i];//统计所有方向上部分棋型的个数 if (i == WIN) eval.STAT[WIN] = count; else if (i == LOSE) eval.STAT[LOSE] = count; } eval.result = R_DRAW; //白赢 if (eval.STAT[WIN] &gt; 0)eval.result = R_WHITE; //黑赢 else if (eval.STAT[LOSE] &gt; 0)eval.result = R_BLACK; eval.score = score; return eval;} 极大极小值搜索算法的核心环节为极大极小值搜索，首先要引入博弈树的概念，就是将己方和敌方的决策构成树，每个节点的分支表示可走位置，每个叶节点表示一个局面。从根节点为0开始，奇数层表示电脑可能的走法，偶数层表示玩家可能的走法。假设电脑先手，那么第一层就是电脑的所有可能的走法，第二层就是玩家的所有可能走法，以此类推。电脑走棋的层我们称为 MAX层，这一层电脑要保证自己利益最大化，那么就需要选分最高的节点。玩家走棋的层我们称为MIN层，这一层玩家要保证自己的利益最大化，那么就会选分最低的节点。而每一个节点的分数，都是由子节点决定的，因此我们要对博弈树进行深度优先搜索，得到根节点的最佳选择。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int analyse(int(*board)[15], int depth, int alpha, int beta) { gameResult RESULT = evaluate(board).result; if (depth == 0 || RESULT != R_DRAW) {//如果模拟落子可以分出输赢，直接返回结果 if (depth == 0) { //搜索到最后一层 SOMEPOINTS P; P = seekPoints(board); //局部搜索与静态评价启发，直接寻找最佳的可能落子位置 return P.score[0]; //返回最佳位置对应的最高分 } else { return evaluate(board).score; //返回当前层分值 } } else if (depth % 2 == 0) {//max层,AI方(白)决策 int sameBoard[15][15]; copyBoard(board, sameBoard); SOMEPOINTS P = seekPoints(sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_WHITE;//模拟AI方落子 int a = analyse(sameBoard, depth - 1, alpha, beta);//递归搜索 sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE;//还原落子 if (a &gt; alpha) { alpha = a; if (depth == 4) {//搜索深度 decision.best.x = P.pos[i].x; //AI决策位置 decision.best.y = P.pos[i].y; decision.eval = a; } } if (beta &lt;= alpha)break; //Alpha-Beta剪枝 } return alpha; } else {//min层,玩家方(黑)决策 int rBoard[15][15]; reverseBoard(board, rBoard); SOMEPOINTS P = seekPoints(rBoard); //寻找黑子的最佳位置，需要反转棋盘颜色 int sameBoard[15][15]; copyBoard(board, sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_BLACK; int a = analyse(sameBoard, depth - 1, alpha, beta); sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE; if (a &lt; beta)beta = a; if (beta &lt;= alpha)break;//剪枝 } return beta; }} Alpha-Beta剪枝通过遍历博弈树来得到最佳的根节点，即使平均每一步只考虑50个节点，思考深度为四层(才具有一定算力)，搜索的节点数达50^4=6250000个。计算机需要多达100秒才可得到结果，因此我们必须对博弈树剪枝。 α-β剪枝算法应用于此类的极大极小值搜索，思想是在深度优先搜索下，对于提前已经排除选择结果外的节点进行剪枝。 具体实现为每一个节点对应有一个α和一个β，α表示目前该节点的最好下界，β表示目前该节点的最好上界。在最开始时，α为负无穷，β为正无穷。然后进行搜索，max层节点每搜索它的一个子节点，就要更新自己的α（下界），而min层节点每搜索它的一个子节点，就要更新自己的β（上界）。如果更新之后发现α&gt;=β了，说明后面的子节点已经不需要进行搜索了，直接剪枝掉。 进一步优化局部搜索对于每次模拟下棋的位置，只需考虑有棋子的附近，无需考虑整个棋盘，能有效减少节点，具体实现为考虑有落子的位置向周围延申三个深度。 静态评价启发将局部搜索得到的位置，先进行对当前局面的简单评估，只考虑分值较高的前十个节点，并将其排序，并有利于Alpha-Beta剪枝更早地发生。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950SOMEPOINTS seekPoints(int(*board)[15]) { bool B[15][15];//局部搜索,每个非空点附近8个方向延伸3个深度 int worth[15][15]; SOMEPOINTS best_points; memset(B, 0, sizeof(B)); for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (board[i][j] != C_NONE) { for (int k = -3; k &lt;= 3; ++k) { if (i + k &gt;= 0 &amp;&amp; i + k &lt; 15) { B[i + k][j] = true; if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i + k][j + k] = true; if (j - k &gt;= 0 &amp;&amp; j - k &lt; 15)B[i + k][j - k] = true; } if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i][j + k] = true; } } } } for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { worth[i][j] = -INT_MAX; if (board[i][j] == C_NONE &amp;&amp; B[i][j] == true) { //对局部搜索的每个位置评估 board[i][j] = C_WHITE; worth[i][j] = evaluate(board).score; board[i][j] = C_NONE; } } } int w; for (int k = 0; k &lt; 10; ++k) { //对分数排序出前十个位置 w = -INT_MAX; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (worth[i][j] &gt; w) { w = worth[i][j]; best_points.pos[k].x = i; best_points.pos[k].y = j; } } } best_points.score[k] = w; worth[best_points.pos[k].x][best_points.pos[k].y] = -INT_MAX;//清除掉上一点,计算下一点的位置和分数 } return best_points;} 至此，AI算法的实现基本完成，优化的结果能达到每步不到0.3秒得到结果。 写在最后此项目实现的五子棋游戏仍有很多不足之处，UI设计较为简陋，AI算法仍有很多提高之处。 完成项目的过程中也遇到了很多困难，也参考了许多教程和源代码，在此列出以表感谢。 陈可佳 博弈五子棋 livingsu 基于c++和qt实现五子棋ai 这是此项目的GitHub链接 github.com/Sami-zzz/gobang","link":"/2021/09/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F-AI%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"AI算法","slug":"AI算法","link":"/tags/AI%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"项目实践","slug":"项目实践","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"}]}