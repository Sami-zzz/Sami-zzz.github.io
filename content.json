{"pages":[],"posts":[{"title":"C语言实现五子棋游戏","text":"C语言课设项目 基于C语言和EasyX图形库实现的五子棋小游戏 AI算法采用极大极小值搜索中应用Alpha-Beta剪枝 实现人机对战等功能 引言博弈算法 零和博弈，又称零和游戏或零和赛局，与非零和博弈相对，是博弈论的一个概念，属非合作博弈。零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有收入，其他方必有所失。 这里所提到的博弈算法适用于有完备信息的，确定性的，轮流行动的两个游戏者的零和游戏，像大多数的棋类游戏，如五子棋，象棋，围棋都满足这些条件，可以通过这套算法实现。 五子棋在今日已经被证明了是一种“不公平”的游戏，黑棋先手绝对占优，并且有先手必胜的套路。因此，五子棋发展出了各种限制黑棋的规则（如三三禁手），此类五子棋被称为“连珠”。 本文实现的五子棋为无禁手五子棋，AI算法较为简单，棋力水平达到业余水平。 界面设计此项目使用vs2019为开发工具，借助了EasyX图形库，实现较为简单的UI 程序基本结构123456789101112131415int main(){ while (1) { if (startGame() == 1) { //startGame函数为开始界面初始化 int win = game1(); //game1，game2函数分别实现人机和玩家pk gameOver1(win); } else { int win = game2(); gameOver2(win); } } return 0;} 开始页面其中涉及音乐和图片素材调用，素材文件路径可改变 涉及的EasyX图形库函数，可在EasyX文档中查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int startGame() { initgraph(600, 600); IMAGE im_start; loadimage(&amp;im_start, _T(&quot;D:\\\\素材\\\\start.jpg&quot;)); //开始界面图片 putimage(0, 0, &amp;im_start); setlinecolor(BLACK); //绘制选择按钮 setfillcolor(RGB(254, 220, 130)); fillrectangle(50, 490, 170, 545); fillrectangle(240, 490, 360, 545); fillrectangle(430, 490, 550, 545); setbkmode(TRANSPARENT); settextcolor(BLACK); LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(25, 0, _T(&quot;黑体&quot;)); outtextxy(60, 510, _T(&quot;人机对战&quot;)); outtextxy(250, 510, _T(&quot;双人游戏&quot;)); outtextxy(440, 510, _T(&quot;退出游戏&quot;)); settextstyle(&amp;nowstyle); mciSendString(_T(&quot;close stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;open D:\\\\素材\\\\background.mp3 alias bgmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play bgmusic repeat&quot;), NULL, 0, NULL); int gamemode = 0; init_tuple6type(); //调用初始化棋形函数，具体在AI算法中实现 while (1) { MOUSEMSG mouse = GetMouseMsg(); // if (mouse.x &gt;= 50 &amp;&amp; mouse.x &lt;= 170 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 1; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 240 &amp;&amp; mouse.x &lt;= 360 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { gamemode = 2; mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic&quot;), NULL, 0, NULL); break; } if (mouse.x &gt;= 430 &amp;&amp; mouse.x &lt;= 550 &amp;&amp; mouse.y &gt;= 490 &amp;&amp; mouse.y &lt;= 545 &amp;&amp; mouse.mkLButton) { mciSendString(_T(&quot;open D:\\\\素材\\\\start.mp3 alias stmusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play stmusic wait&quot;), NULL, 0, NULL); exit(0); } } mciSendString(_T(&quot;close bgmusic&quot;), NULL, 0, NULL); return gamemode;} 棋盘数据 棋盘数据由结构体数组储存 12345678typedef struct node { //棋盘每个节点的数据储存 int x; //左上顶点坐标 int y; int model; //格子边框样式 int value; //是否落子（0代表无, 黑棋1, 白棋2） bool isnew; //是否显示选择框 COLORREF color; //格子颜色}NODE; 全局变量 12NODE map[15][15];COLORREF COLOR = RGB(255, 183, 111); 棋盘绘制 初始化棋盘数组中的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void initNode(){ for (int i = 75, k = 0; i &lt;= 495; i = i + 30) { for (int j = 75, g = 0; j &lt;= 495; j = j + 30) { map[k][g].x = j; map[k][g].y = i; map[k][g].value = 0; map[k][g].isnew = false; map[k][g].color = COLOR; if (k == 0 &amp;&amp; g == 0) //根据格子位置判断格子边框 { map[k][g].model = 8; } else if (k == 0 &amp;&amp; g == 14) { map[k][g].model = 7; } else if (k == 14 &amp;&amp; g == 14) { map[k][g].model = 6; } else if (k == 14 &amp;&amp; g == 0) { map[k][g].model = 5; } else if (k == 0) { map[k][g].model = 3; } else if (k == 14) { map[k][g].model = 4; } else if (g == 0) { map[k][g].model = 1; } else if (g == 14) { map[k][g].model = 2; } else if ((k == 3 &amp;&amp; g == 3) || (k == 3 &amp;&amp; g == 11) || (k == 11 &amp;&amp; g == 3) || (k == 11 &amp;&amp; g == 11) || (k == 7 &amp;&amp; g == 7)) { map[k][g].model = 9; } else { map[k][g].model = 0; } g++; } k++; } } 下棋时，棋盘会随着鼠标移动显示选择框，避免不断绘制整个棋盘导致的闪屏，于是将棋盘绘制设计为每个格子逐个绘制，在更新选择框时仅重新绘制当前位置的图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138void drawNode(NODE* node){ int x = node-&gt;x; //获得当前节点数据 int y = node-&gt;y; int model = node-&gt;model; int value = node-&gt;value; int isnew = node-&gt;isnew; COLORREF color = node-&gt;color; setfillcolor(color); solidrectangle(x, y, x + 30, y + 30); //绘制边框 setlinecolor(BLACK); switch (model) { case 0: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); break; // * // * * * // * case 3: setlinestyle(PS_SOLID, 2); line(x + 15, y + 15, x + 15, y + 30); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * * * // * // * case 4: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 30, y + 15); break; // * // * // * * * case 1: setlinestyle(PS_SOLID, 2); line(x + 14, y + 15, x + 30, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 2: setlinestyle(PS_SOLID, 2); line(x - 1, y + 15, x + 15, y + 15); setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 30); break; // * // * * * // * case 7: setlinestyle(PS_SOLID, 3); line(x - 1, y + 15, x + 15, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 6: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x - 1, y + 15, x + 15, y + 15); break; // * // * // * * * case 5: setlinestyle(PS_SOLID, 3); line(x + 15, y, x + 15, y + 15); line(x + 15, y + 15, x + 30, y + 15); break; // * // * // * * * case 8: setlinestyle(PS_SOLID, 3); line(x + 15, y + 15, x + 30, y + 15); line(x + 15, y + 15, x + 15, y + 30); break; // * * * // * // * case 9: setlinestyle(PS_SOLID, 2); line(x + 15, y, x + 15, y + 30); line(x - 1, y + 15, x + 30, y + 15); setfillcolor(BLACK); setlinestyle(PS_SOLID, 2); fillcircle(x + 15, y + 15, 4); break; // * // * O * // * } //绘制选择框 if (isnew) { setlinestyle(PS_SOLID, 2); setlinecolor(LIGHTGRAY); line(x + 1, y + 2, x + 8, y + 2); line(x + 2, y + 1, x + 2, y + 8); line(x + 29, y + 2, x + 22, y + 2); line(x + 29, y + 1, x + 29, y + 8); line(x + 2, y + 29, x + 8, y + 29); line(x + 2, y + 22, x + 2, y + 29); line(x + 29, y + 29, x + 22, y + 29); line(x + 29, y + 22, x + 29, y + 29); } //绘制棋子 switch (value) { case 1: setfillcolor(BLACK); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; case 2: setfillcolor(WHITE); setlinecolor(BLACK); setlinestyle(PS_SOLID, 1); fillcircle(x + 15, y + 15, 12); break; }} 绘制整个棋盘函数，不断调用绘制格子函数 12345678910111213141516171819202122232425262728293031void drawBoard(){ //更新每一个节点 for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { drawNode(&amp;map[i][j]); if (map[i][j].isnew == true) { map[i][j].isnew = false; // 把上一个下棋位置的选择框清除 } } } // 绘制坐标 TCHAR strnum[19][3] = { _T(&quot;1&quot;),_T(&quot;2&quot;) ,_T(&quot;3&quot;) ,_T(&quot;4&quot;),_T(&quot;5&quot;) ,_T(&quot;6&quot;) ,_T(&quot;7&quot;),_T(&quot;8&quot;),_T(&quot;9&quot;),_T(&quot;10&quot;), _T(&quot;11&quot;),_T(&quot;12&quot;) ,_T(&quot;13&quot;) ,_T(&quot;14&quot;),_T(&quot;15&quot;) }; TCHAR strabc[19][3] = { _T(&quot;A&quot;),_T(&quot;B&quot;) ,_T(&quot;C&quot;) ,_T(&quot;D&quot;),_T(&quot;E&quot;) ,_T(&quot;F&quot;) ,_T(&quot;G&quot;),_T(&quot;H&quot;),_T(&quot;I&quot;),_T(&quot;J&quot;), _T(&quot;K&quot;),_T(&quot;L&quot;) ,_T(&quot;M&quot;) ,_T(&quot;N&quot;),_T(&quot;O&quot;) }; LOGFONT nowstyle; gettextstyle(&amp;nowstyle); settextstyle(0, 0, NULL); settextcolor(BLACK); int number = 0; for (int i = 0; i &lt; 15; i++) { outtextxy(85 + number, 60, strnum[i]); outtextxy(60, 85 + number, strabc[i]); number += 30; } } 游戏函数 game1为实现人机对战的函数，其中关于AI算法函数稍后实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int game1() { //人机对战实现 Sleep(500); setbkcolor(COLOR); cleardevice(); initNode(); drawBoard(); settextstyle(20, 10, 0, 0, 0, 1000, false, false, false); settextcolor(BLACK); settextstyle(25, 0, NULL); outtextxy(90, 530, _T(&quot;玩家执黑先行&quot;)); int whoplay = 0; int oldi = 0; //更新鼠标位置所储存的坐标 int oldj = 0; while (1) { if (whoplay == 0) { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); MOUSEMSG mouse = GetMouseMsg(); if (mouse.x &gt;= 75 &amp;&amp; mouse.y &gt;= 75 &amp;&amp; mouse.x &lt;= 525 &amp;&amp; mouse.y &lt;= 525) { //判断鼠标所处节点 int j = (mouse.x - 75) / 30; int i = (mouse.y - 75) / 30; //判断是否是空位置 if (map[i][j].value == 0) { // 如果按下了 if (mouse.mkLButton) { map[i][j].value = C_BLACK; // 下棋 map[i][j].isnew = true; //更新选择框 whoplay = 1; //轮到下一个 drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { //判断是否获胜 return win; } oldi = 0; oldj = 0; continue; } // 更新节点 map[oldi][oldj].isnew = false; drawNode(&amp;map[oldi][oldj]); map[i][j].isnew = true; drawNode(&amp;map[i][j]); oldi = i; oldj = j; } } } else { mciSendString(_T(&quot;close domusic&quot;), NULL, 0, NULL); int board[15][15]; mapToBoard(map, board); //AI下棋 analyse(board, 4, -INT_MAX, INT_MAX); //AI算法实现函数，应用极大极小值搜索 map[decision.best.x][decision.best.y].value = C_WHITE; map[decision.best.x][decision.best.y].isnew = true; whoplay = 0; drawBoard(); mciSendString(_T(&quot;open D:\\\\素材\\\\down.mp3 alias domusic&quot;), NULL, 0, NULL); mciSendString(_T(&quot;play domusic wait&quot;), NULL, 0, NULL); int win; if ((win = winner()) != 0) { return win; } oldi = 0; oldj = 0; } }} 胜负判断 每次落子后调用胜负判断函数，若有一方胜出则结束游戏 123456789101112131415161718192021222324252627282930313233343536373839404142int winner(){ int iswin = 0; int dx[4] = { 1, 0, 1, 1 }; //向四种方向搜索棋盘 int dy[4] = { 0, 1, 1, -1 }; bool isfull = true; for (int i = 0; i &lt; 15; i++) { for (int j = 0; j &lt; 15; j++) { if (map[i][j].value != 0) { int nowcolor = map[i][j].value; int length[4] = { 0, 0, 0, 0 }; for (int k = 0; k &lt; 4; k++) { int nowi = i; int nowj = j; while (map[nowi][nowj].value == nowcolor &amp;&amp; nowi &gt;= 0 &amp;&amp; nowi &lt;= 14 &amp;&amp; nowj &gt;= 0 &amp;&amp; nowj &lt;= 14) { length[k]++; nowi += dx[k]; nowj += dy[k]; } } for (int k = 0; k &lt; 4; k++) { if (length[k] &gt;= 5) { if (nowcolor == C_BLACK) { iswin = 1; } else { iswin = 2; } } } } else { isfull = false; } } } if (isfull) { iswin = 3; } return iswin;} 五子棋界面设计差不多已经完成，AI下棋的算法在下一篇 C语言实现五子棋游游戏(AI算法实现)","link":"/2021/07/16/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F/"},{"title":"LeetCode 611. 有效三角形的个数","text":"给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例1： 1234567输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3 解题思路1.暴力​ 这道题要求枚举符合条件的三元组，最简单的方法是通过三层循环直接枚举所有的组合，对三边都进行 a+b&lt;c &amp;&amp; a+c&lt;b &amp;&amp; b+c&lt;a 的判断，累加求出个数。 2.排序+二分​ 首先我们对数组进行排序，对于已排序数组，即三元组a &lt; b &lt; c，当且仅当 a + b &gt; c时符合条件，因此我们可以通过两层循环固定a,b，对于c在有序区间中找到小于a+b的最大值，则(b,c]中的元素个数即为当前a,b对应的解个数，累加即可。 ​ 时间复杂度为 $n^2log(n)$ 12345678910111213141516171819202122232425class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; int res = 0; int left, right, mid; for(int i = 0; i &lt; n - 2; i++){ for(int j = i + 1; j &lt; n - 1; j++){ left = j + 1; right = n - 1; while(left &lt; right){ mid = (left + right + 1) / 2; if(nums[mid] &gt;= nums[i] + nums[j]){ right = mid - 1; }else{ left = mid; } } if(nums[left] &lt; nums[i] + nums[j]) res += left - j; } } return res; }} 3.排序+双指针​ 依然首先对数组排序，我们考虑a + b &gt; c的条件，我们可以先固定最长边c，通过双指针来寻找a,b。一个关键点在于反向遍历c，每一个c对应的left和right指针，left=0，right=k-1。​ 如果nums[left] + nums[right] &gt; c,则[left, right]区间的所有数符合条件，right左移；​ 如果nums[left] + nums[right] &lt;= c,则left右移，直到大于c。​ 最后left于right碰撞，即已经找完当前c对应的所有解。 ​ 时间复杂度为 $n^2$ 1234567891011121314151617181920class Solution { public int triangleNumber(int[] nums) { Arrays.sort(nums); int n = nums.length; int res = 0; for(int i = n-1; i&gt;=2; i--){ int right = i-1; int left = 0; while(left &lt; right){ if(nums[left] + nums[right] &gt; nums[i]){ res += right - left; right--; }else{ left++; } } } return res; }}","link":"/2021/12/29/LeetCode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"LeetCode 658.找到K个最接近的元素","text":"给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。 返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： |a - x| &lt; |b - x| 或者|a - x| == |b - x| 且 a &lt; b 示例 1： 12输入：arr = [1,2,3,4,5], k = 4, x = 3输出：[1,2,3,4] 解题思路1.排除法（双指针）我们可以反向来思考这道题，即删去n-k个最不接近的元素，剩下的元素即为最接近的k个。 我们设置指向头尾的两个指针left，right，每次删除掉相差更远的元素，对应指针向内缩减。 时间复杂度为$O(n)$ 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) { int n = arr.length; int left = 0; int right = n - 1; int removeNum = n - k; while(removeNum-- &gt; 0){ if(x - arr[left] &lt;= arr[right] - x){ right--; }else{ left++; } } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; k; i++){ list.add(arr[left + i]); } return list; }} 这里两数之差的比较没有采用绝对值，而是x - arr[left] &lt;= arr[right] - x，一种比较容易理解的方法是 x &lt;= (arr[left] + arr[right]) / 2; 2.二分查找我们要找最接近的k个数，当我们找到最优区间的最左边的那个数时，问题也相应解决。 这最优区间的最左边的数只会存在于区间 [0， n - k]。就可以通过二分查找在这区间中找到答案，设这个值为target。 令left = 0， right=n-k，二分mid=（left + right）/ 2, 二分的手段可以认为是一种随机选取，目的是通过二分可以快速排除不可能存在target的区间。 关键在于每次的判断条件，我们考虑 [mid, mid+k]这个k+1的区间，因为是k+1个数，我们必能够排除一个相对于x更远的数，同解法一类似，若arr[mid + k]与x更接近，则删除最左端也就是mid所指的数，因此mid及mid左边的数不可能是最优左边界（target），令left = mid + 1; 相反,则要删除最右端的数，导致的结果是mid的右边都不可能是target，令right = mid。通过这种判断手段，来在可能区间中定位target。 时间复杂度$O(logn + k)$ 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) { int n = arr.length; int left = 0; int right = n - k; int mid; while(left &lt; right){ mid = (left + right) /2; if(x - arr[mid] &gt; arr[mid + k] - x){ left = mid + 1; }else{ right = mid; } } List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i = 0; i&lt; k; i++){ list.add(arr[left + i]); } return list; }}","link":"/2021/12/29/LeetCode-658-%E6%89%BE%E5%88%B0K%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/"},{"title":"LeetCode7-53","text":"LeetCode07 整数反转 LeetCode53 最大子序和 leetcode7 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 1234567891011121314class Solution {public: int reverse(int x) { int result = 0; while(x != 0){ if(result &gt; INT_MAX / 10 || result &lt; INT_MIN / 10) return 0; int a = x % 10; x /= 10; result = result * 10 + a; } return result; } }; 这道题的算法思想为通过数学的方法，模拟数字的弹出和推入，关键点在于溢出的检测。 2^31-1=2147483647 -2^31=-2147483648 我们要保证返回的result不会溢出，就要在数字推入result前检测，方法为 1if(result &gt; INT_MAX / 10 || result &lt; INT_MIN / 10) 不能使用result * 10 &lt; INT_MAX. 这条语句同时也保证了推入数字a时也不会溢出，因为若要溢出，原数据x为10位数并且也小于INT_MAX，则最后推入的数字一定小于等于2，不会大于7而导致溢出，小于零时同理。 复杂度分析 时间复杂度：O(log |x|)。翻转的次数即 x十进制的位数 leetcode53 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 1234567891011class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int pre = 0, maxAns = nums[0]; for (int i = 0; i &lt; nums.size(); i++) { pre = max(pre + nums[i], nums[i]); maxAns = max(maxAns, pre); } return maxAns; }}; 动态规划 我们通常的惯性思维是以子序列的开头为基准，先遍历出以 a 为开头的所有子序列，再遍历出以 b 为开头的…但是动态规划为了找到不同子序列之间的递推关系，恰恰是以子序列的结束点为基准的 为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」 定义状态（定义子问题）dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。 状态转移方程$$dp[i]=\\begin{cases}dp[i-1]+nums[i],dp[i-1]&gt;0\\nums[i],dp[i-1]\\le0\\end{cases}$$ 还可以写成这样 $dp[i] = max{dp[i-1]+nums[i],,,,nums[i]}$ 输出把所有的 dp[0]、dp[1]、……、dp[n - 1] 都看一遍，取最大值 优化空间dp[i] 的值只与dp[i-1]有关，可以只使用一个变量来维护dp[i-1], 空间复杂度优化到O(1)。","link":"/2021/09/12/LeetCode7-53/"},{"title":"数据结构和算法：双指针技巧","text":"双指针技巧，常用于数组和链表此类数据结构中，通过前后指针和快慢指针在单次遍历或少次遍历中求解问题 数组数组可以双向操作，双指针可前后遍历或同向遍历 167.两数之和Ⅱ-输入有序数组 easy： 给定一个已按照 非递减顺序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 。 使用双指针，分别从数组头尾遍历，若和小于目标值，则左指针右移，若大于目标值，则右指针左移。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int hi = numbers.size() - 1; int lo = 0; while(lo &lt; hi) { if(numbers[lo] + numbers[hi] == target) { return {lo + 1, hi + 1}; }else if(numbers[lo] + numbers[hi] &lt; target) { lo++; }else{ hi--; } } return {}; }}; 209.长度最小的子数组medium： 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 。 滑动窗口：定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和 初始状态下，start 和 end 都指向下标 0 ，sum 的值为 0。 每一轮迭代，将 nums[end] 加到 sum，如果 sum ≥ s，则更新子数组的最小长度，然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum &lt; s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int hi = numbers.size() - 1; int lo = 0; while(lo &lt; hi) { if(numbers[lo] + numbers[hi] == target) { return {lo + 1, hi + 1}; }else if(numbers[lo] + numbers[hi] &lt; target) { lo++; }else{ hi--; } } return {}; }}; 链表这里提到的链表都为单链表，因此常用同向的快慢指针 141.环形链表 easy: 给定一个链表，判断链表中是否有环，如果链表中存在环，则返回 true 。 否则，返回 false .快慢指针：涉及「Floyd 判圈算法」（又称龟兔赛跑算法） ​ 定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { if(head==nullptr || head-&gt;next==nullptr) { return false; } ListNode* slow = head; ListNode* fast = head-&gt;next; while(slow!=fast) { if(fast==nullptr || fast-&gt;next == nullptr) { return false; } fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; } return true; }}; 142.环形链表Ⅱ medium：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null 快慢指针：定义两个指针fast和slow，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步，fast指针走过链表末端，说明链表无环； 当fast == slow时， 两指针在环中第一次相遇，设环长为b, 去掉环链长为a, 根据： ​ f = 2s （快指针每次2步，路程刚好2倍） ​ f = s + nb (相遇时，刚好多走了n圈） 推出：s = nb 从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。 如何知道slow刚好走了a步, 可以让一指针从head开始，和slow指针一起走，则相遇时刚好就是a步。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(!(fast == nullptr || fast-&gt;next == nullptr)){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast==slow){ fast = head; while(fast!=slow){ fast=fast-&gt;next; slow=slow-&gt;next; } return slow; } } return nullptr; }}; 160.相交链表 easy: 给你两个单链表的头节点 headA和headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 双指针：无论两链表是否相交，只需要将链表LA和链表LB的链尾对齐，然后从后向前依次比较节点是否相同即可。1.从后向前访问的第一节点既不是公共节点则两链表不相交。2.从后向前访问的公共节点中最后访问的公共节点则为两链表相交的第一个节点 因为单链表无法向前遍历节点，但是可以将LA+LB和LB+LA的两条轨道拼接起来，此时尾部对齐，从前往后遍历就能找到公共节点 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if(headA==nullptr || headB==nullptr){ return nullptr; } ListNode* pA = headA; ListNode* pB = headB; while(pA != pB) { pA = pA == nullptr ? headB : pA-&gt;next; pB = pB == nullptr ? headA : pB-&gt;next; } return pA; }};","link":"/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/"},{"title":"C语言实现五子棋游戏(AI算法实现)","text":"接上文C语言实现五子棋游戏，此文为AI算法的实现 主要为极大极小值搜索中应用Alpha-Beta剪枝 AI 算法算法思想AI算法主要思想是，电脑模拟人机双方下棋，并对落子后的局面进行评分，将分值构建成一棵树，再遍历寻找出最优解。 评估函数 首先要先实现对整个棋盘局面打分的评估函数，我设计了一个六元数组来识别五子棋的各种棋形，包括连五，活四，冲四等 然后设计一个各种棋形的权重表，用于打分，赋分有以下几个要点， 1.对于AI下棋的白棋方来说，将数值赋为正，黑棋棋形赋为负，并且相同棋形下黑棋的权重要更大，应为当AI白棋落子后即为黑子落子。 2.对于黑棋方(玩家)的连五，活四，冲四，活三等接近胜利的棋形权重要更大，同样原因是AI下完棋就到玩家下棋 3.棋形分值等级：连5&gt;活4&gt;冲4=活3&gt;眠3=活2&gt;眠2=活1，相邻等级的权重设置为相差20倍（也可以30，40倍），这是因为会重复计算等级比较低的棋型，以此避免影响总体判断。 设计各棋形的分值 123456789101112131415161718192021222324//棋子代号#define C_NONE 0#define C_BLACK 1#define C_WHITE 2//棋型代号 下标 权重#define OTHER 0//0,其他棋型不考虑#define WIN 1//100000,白赢#define LOSE 2//-10000000,黑赢#define FLEX4 3//50000,白活#define flex4 4//-80000,黑活#define BLOCK4 5//400#define block4 6//-80000#define FLEX3 7//400#define flex3 8//-8000#define BLOCK3 9//20#define block3 10//-40#define FLEX2 11//20#define flex2 12//-40#define BLOCK2 13//1#define block2 14//-2#define FLEX1 15//1#define flex1 16//-2 初始化棋形判别六元组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189void init_tuple6type() { memset(tuple6type, 0, sizeof(tuple6type)); //白连5,ai赢 tuple6type[2][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][0] = WIN; tuple6type[0][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][1] = WIN; tuple6type[1][2][2][2][2][2] = WIN; tuple6type[3][2][2][2][2][2] = WIN; tuple6type[2][2][2][2][2][3] = WIN; //黑连5,ai输 tuple6type[1][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][0] = LOSE; tuple6type[0][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][2] = LOSE; tuple6type[2][1][1][1][1][1] = LOSE; tuple6type[3][1][1][1][1][1] = LOSE; tuple6type[1][1][1][1][1][3] = LOSE; //白活4 tuple6type[0][2][2][2][2][0] = FLEX4; //黑活4 tuple6type[0][1][1][1][1][0] = flex4; //白活3 tuple6type[0][2][2][2][0][0] = FLEX3; tuple6type[0][0][2][2][2][0] = FLEX3; tuple6type[0][2][0][2][2][0] = FLEX3; tuple6type[0][2][2][0][2][0] = FLEX3; //黑活3 tuple6type[0][1][1][1][0][0] = flex3; tuple6type[0][0][1][1][1][0] = flex3; tuple6type[0][1][0][1][1][0] = flex3; tuple6type[0][1][1][0][1][0] = flex3; //白活2 tuple6type[0][2][2][0][0][0] = FLEX2; tuple6type[0][2][0][2][0][0] = FLEX2; tuple6type[0][2][0][0][2][0] = FLEX2; tuple6type[0][0][2][2][0][0] = FLEX2; tuple6type[0][0][2][0][2][0] = FLEX2; tuple6type[0][0][0][2][2][0] = FLEX2; //黑活2 tuple6type[0][1][1][0][0][0] = flex2; tuple6type[0][1][0][1][0][0] = flex2; tuple6type[0][1][0][0][1][0] = flex2; tuple6type[0][0][1][1][0][0] = flex2; tuple6type[0][0][1][0][1][0] = flex2; tuple6type[0][0][0][1][1][0] = flex2; //白活1 tuple6type[0][2][0][0][0][0] = FLEX1; tuple6type[0][0][2][0][0][0] = FLEX1; tuple6type[0][0][0][2][0][0] = FLEX1; tuple6type[0][0][0][0][2][0] = FLEX1; //黑活1 tuple6type[0][1][0][0][0][0] = flex1; tuple6type[0][0][1][0][0][0] = flex1; tuple6type[0][0][0][1][0][0] = flex1; tuple6type[0][0][0][0][1][0] = flex1; int p1, p2, p3, p4, p5, p6, x, y, ix, iy;//x:左5中黑个数,y:左5中白个数; ix:右5中黑个数,iy:右5中白个数 for (p1 = 0; p1 &lt; 4; ++p1) { for (p2 = 0; p2 &lt; 3; ++p2) { for (p3 = 0; p3 &lt; 3; ++p3) { for (p4 = 0; p4 &lt; 3; ++p4) { for (p5 = 0; p5 &lt; 3; ++p5) { for (p6 = 0; p6 &lt; 4; ++p6) { x = y = ix = iy = 0; if (p1 == 1)x++; else if (p1 == 2)y++; if (p2 == 1) { x++; ix++; } else if (p2 == 2) { y++; iy++; } if (p3 == 1) { x++; ix++; } else if (p3 == 2) { y++; iy++; } if (p4 == 1) { x++; ix++; } else if (p4 == 2) { y++; iy++; } if (p5 == 1) { x++; ix++; } else if (p5 == 2) { y++; iy++; } if (p6 == 1)ix++; else if (p6 == 2)iy++; if (p1 == 3 || p6 == 3) {//有边界 if (p1 == 3 &amp;&amp; p6 != 3) {//左边界 //白冲4 if (ix == 0 &amp;&amp; iy == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (ix == 4 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if (ix == 0 &amp;&amp; iy == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if (ix == 3 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if (ix == 0 &amp;&amp; iy == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if (ix == 2 &amp;&amp; iy == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } else if (p6 == 3 &amp;&amp; p1 != 3) {//右边界 //白冲4 if (x == 0 &amp;&amp; y == 4) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if (x == 4 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //黑眠3 if (x == 3 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //白眠3 if (x == 0 &amp;&amp; y == 3) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //黑眠2 if (x == 2 &amp;&amp; y == 0) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //白眠2 if (x == 0 &amp;&amp; y == 2) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } else {//无边界 //白冲4 if ((x == 0 &amp;&amp; y == 4) || (ix == 0 &amp;&amp; iy == 4)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK4; } //黑冲4 if ((x == 4 &amp;&amp; y == 0) || (ix == 4 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block4; } //白眠3 if ((x == 0 &amp;&amp; y == 3) || (ix == 0 &amp;&amp; iy == 3)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK3; } //黑眠3 if ((x == 3 &amp;&amp; y == 0) || (ix == 3 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block3; } //白眠2 if ((x == 0 &amp;&amp; y == 2) || (ix == 0 &amp;&amp; iy == 2)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = BLOCK2; } //黑眠2 if ((x == 2 &amp;&amp; y == 0) || (ix == 2 &amp;&amp; iy == 0)) { if (tuple6type[p1][p2][p3][p4][p5][p6] == 0) tuple6type[p1][p2][p3][p4][p5][p6] = block2; } } } } } } } }} 基于以上的棋形分值和判别数组实现对当前棋盘的分值评估 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778EVALUATION evaluate(int(*board)[15]) { int weight[17] = { 0,1000000,-10000000,50000,-100000,400,-100000,400,-8000,20,-50,20,-50,1,-3,1,-3 };//各棋型权重 int type; int stat[4][17];//统计4个方向上每种棋型的个数 memset(stat, 0, sizeof(stat)); int STAT[17];//存在这种棋型的方向的个数 memset(STAT, 0, sizeof(STAT)); int A[17][17];//包括边界的虚拟大棋盘,3表示边界 for (int i = 0; i &lt; 17; ++i) A[i][0] = 3; for (int i = 0; i &lt; 17; ++i) A[i][16] = 3; for (int j = 0; j &lt; 17; ++j) A[0][j] = 3; for (int j = 0; j &lt; 17; ++j) A[16][j] = 3; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { A[i + 1][j + 1] = board[i][j]; } } //判断横向棋型 for (int i = 1; i &lt;= 15; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i][j + 1]][A[i][j + 2]][A[i][j + 3]][A[i][j + 4]][A[i][j + 5]]; stat[0][type]++; } } //判断竖向棋型 for (int j = 1; j &lt;= 15; ++j) { for (int i = 0; i &lt; 12; ++i) { type = tuple6type[A[i][j]][A[i + 1][j]][A[i + 2][j]][A[i + 3][j]][A[i + 4][j]][A[i + 5][j]]; stat[1][type]++; } } //判断左上至右下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 0; j &lt; 12; ++j) { type = tuple6type[A[i][j]][A[i + 1][j + 1]][A[i + 2][j + 2]][A[i + 3][j + 3]][A[i + 4][j + 4]][A[i + 5][j + 5]]; stat[2][type]++; } } //判断右上至左下棋型 for (int i = 0; i &lt; 12; ++i) { for (int j = 5; j &lt; 17; ++j) { type = tuple6type[A[i][j]][A[i + 1][j - 1]][A[i + 2][j - 2]][A[i + 3][j - 3]][A[i + 4][j - 4]][A[i + 5][j - 5]]; stat[3][type]++; } } EVALUATION eval;//评估结果 memset(eval.STAT, 0, sizeof(eval.STAT)); int score = 0; for (int i = 1; i &lt; 17; ++i) { score += (stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i]) * weight[i];//计分 int count = stat[0][i] + stat[1][i] + stat[2][i] + stat[3][i];//统计所有方向上部分棋型的个数 if (i == WIN) eval.STAT[WIN] = count; else if (i == LOSE) eval.STAT[LOSE] = count; } eval.result = R_DRAW; //白赢 if (eval.STAT[WIN] &gt; 0)eval.result = R_WHITE; //黑赢 else if (eval.STAT[LOSE] &gt; 0)eval.result = R_BLACK; eval.score = score; return eval;} 极大极小值搜索算法的核心环节为极大极小值搜索，首先要引入博弈树的概念，就是将己方和敌方的决策构成树，每个节点的分支表示可走位置，每个叶节点表示一个局面。从根节点为0开始，奇数层表示电脑可能的走法，偶数层表示玩家可能的走法。假设电脑先手，那么第一层就是电脑的所有可能的走法，第二层就是玩家的所有可能走法，以此类推。电脑走棋的层我们称为 MAX层，这一层电脑要保证自己利益最大化，那么就需要选分最高的节点。玩家走棋的层我们称为MIN层，这一层玩家要保证自己的利益最大化，那么就会选分最低的节点。而每一个节点的分数，都是由子节点决定的，因此我们要对博弈树进行深度优先搜索，得到根节点的最佳选择。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int analyse(int(*board)[15], int depth, int alpha, int beta) { gameResult RESULT = evaluate(board).result; if (depth == 0 || RESULT != R_DRAW) {//如果模拟落子可以分出输赢，直接返回结果 if (depth == 0) { //搜索到最后一层 SOMEPOINTS P; P = seekPoints(board); //局部搜索与静态评价启发，直接寻找最佳的可能落子位置 return P.score[0]; //返回最佳位置对应的最高分 } else { return evaluate(board).score; //返回当前层分值 } } else if (depth % 2 == 0) {//max层,AI方(白)决策 int sameBoard[15][15]; copyBoard(board, sameBoard); SOMEPOINTS P = seekPoints(sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_WHITE;//模拟AI方落子 int a = analyse(sameBoard, depth - 1, alpha, beta);//递归搜索 sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE;//还原落子 if (a &gt; alpha) { alpha = a; if (depth == 4) {//搜索深度 decision.best.x = P.pos[i].x; //AI决策位置 decision.best.y = P.pos[i].y; decision.eval = a; } } if (beta &lt;= alpha)break; //Alpha-Beta剪枝 } return alpha; } else {//min层,玩家方(黑)决策 int rBoard[15][15]; reverseBoard(board, rBoard); SOMEPOINTS P = seekPoints(rBoard); //寻找黑子的最佳位置，需要反转棋盘颜色 int sameBoard[15][15]; copyBoard(board, sameBoard); for (int i = 0; i &lt; 10; ++i) { sameBoard[P.pos[i].x][P.pos[i].y] = C_BLACK; int a = analyse(sameBoard, depth - 1, alpha, beta); sameBoard[P.pos[i].x][P.pos[i].y] = C_NONE; if (a &lt; beta)beta = a; if (beta &lt;= alpha)break;//剪枝 } return beta; }} Alpha-Beta剪枝通过遍历博弈树来得到最佳的根节点，即使平均每一步只考虑50个节点，思考深度为四层(才具有一定算力)，搜索的节点数达50^4=6250000个。计算机需要多达100秒才可得到结果，因此我们必须对博弈树剪枝。 α-β剪枝算法应用于此类的极大极小值搜索，思想是在深度优先搜索下，对于提前已经排除选择结果外的节点进行剪枝。 具体实现为每一个节点对应有一个α和一个β，α表示目前该节点的最好下界，β表示目前该节点的最好上界。在最开始时，α为负无穷，β为正无穷。然后进行搜索，max层节点每搜索它的一个子节点，就要更新自己的α（下界），而min层节点每搜索它的一个子节点，就要更新自己的β（上界）。如果更新之后发现α&gt;=β了，说明后面的子节点已经不需要进行搜索了，直接剪枝掉。 进一步优化局部搜索对于每次模拟下棋的位置，只需考虑有棋子的附近，无需考虑整个棋盘，能有效减少节点，具体实现为考虑有落子的位置向周围延申三个深度。 静态评价启发将局部搜索得到的位置，先进行对当前局面的简单评估，只考虑分值较高的前十个节点，并将其排序，并有利于Alpha-Beta剪枝更早地发生。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950SOMEPOINTS seekPoints(int(*board)[15]) { bool B[15][15];//局部搜索,每个非空点附近8个方向延伸3个深度 int worth[15][15]; SOMEPOINTS best_points; memset(B, 0, sizeof(B)); for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (board[i][j] != C_NONE) { for (int k = -3; k &lt;= 3; ++k) { if (i + k &gt;= 0 &amp;&amp; i + k &lt; 15) { B[i + k][j] = true; if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i + k][j + k] = true; if (j - k &gt;= 0 &amp;&amp; j - k &lt; 15)B[i + k][j - k] = true; } if (j + k &gt;= 0 &amp;&amp; j + k &lt; 15)B[i][j + k] = true; } } } } for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { worth[i][j] = -INT_MAX; if (board[i][j] == C_NONE &amp;&amp; B[i][j] == true) { //对局部搜索的每个位置评估 board[i][j] = C_WHITE; worth[i][j] = evaluate(board).score; board[i][j] = C_NONE; } } } int w; for (int k = 0; k &lt; 10; ++k) { //对分数排序出前十个位置 w = -INT_MAX; for (int i = 0; i &lt; 15; ++i) { for (int j = 0; j &lt; 15; ++j) { if (worth[i][j] &gt; w) { w = worth[i][j]; best_points.pos[k].x = i; best_points.pos[k].y = j; } } } best_points.score[k] = w; worth[best_points.pos[k].x][best_points.pos[k].y] = -INT_MAX;//清除掉上一点,计算下一点的位置和分数 } return best_points;} 至此，AI算法的实现基本完成，优化的结果能达到每步不到0.3秒得到结果。 写在最后此项目实现的五子棋游戏仍有很多不足之处，UI设计较为简陋，AI算法仍有很多提高之处。 完成项目的过程中也遇到了很多困难，也参考了许多教程和源代码，在此列出以表感谢。 陈可佳 博弈五子棋 livingsu 基于c++和qt实现五子棋ai 这是此项目的GitHub链接 github.com/Sami-zzz/gobang","link":"/2021/09/12/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F-AI%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"},{"title":"JS DOM技术","text":"DOM技术DOM简介文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口 W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式 文档：一个页面就是一个文档，DOM中使用doucument来表示 元素：页面中的所有标签都是元素，DOM中使用 element 表示 节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示 DOM 把以上内容都看做是对象 获取元素获取页面元素DOM在我们实际开发中主要用来操作元素。 获取页面中的元素可以使用以下几种方式: 根据 ID 获取 根据标签名获取 通过 HTML5 新增的方法获取 特殊元素获取 根据ID获取使用 getElementByld() 方法可以获取带ID的元素对象 1doucument.getElementByld('id名') 使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。 123456789101112&lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;&lt;script&gt; // 1.因为我们文档页面从上往下加载，所以得先有标签，所以script写在标签下面 // 2.get 获得 element 元素 by 通过 驼峰命名法 // 3.参数 id是大小写敏感的字符串 // 4.返回的是一个元素对象 var timer = document.getElementById('time'); console.log(timer); // 5. console.dir 打印我们的元素对象，更好的查看里面的属性和方法 console.dir(timer);&lt;/script&gt; 根据标签名获取根据标签名获取，使用 getElementByTagName() 方法可以返回带有指定标签名的对象的集合 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历 得到元素对象是动态的 返回的是获取过来元素对象的集合，以伪数组的形式存储 如果获取不到元素，则返回为空的伪数组(因为获取不到对象) 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1.返回的是获取过来元素对象的集合 以伪数组的形式存储 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 2.依次打印,遍历 for (var i = 0; i &lt; lis.length; i++) { console.log(lis[i]); } // 3.如果页面中只有 1 个 li，返回的还是伪数组的形式 // 4.如果页面中没有这个元素，返回的是空伪数组&lt;/script&gt; 还可以根据标签名获取某个元素（父元素）内部所有指定标签名的子元素,获取的时候不包括父元素自己 12345&lt;script&gt; //element.getElementsByTagName('标签名'); 父元素必须是指定的单个元素 var ol = document.getElementById('ol'); console.log(ol.getElementsByTagName('li'));&lt;/script&gt; H5新增方法获取根据类名获取根据类名获取，使用 getElementByClassName() 方法可以返回带有指定类名的对象的集合 1document.getElementsByClassName('类名'); 根据指定选择器获取根据指定选择器获取，使用 querySelector()方法返回第一个元素对象 使用 querySelectorAll()方法获取指定选择器返回的所有元素对象 123456document.querySelector('选择器');// 切记里面的选择器需要加符号 // 类选择器.box // id选择器 #navvar firstBox = document.querySelector('.box'); 获取特殊元素返回body元素对象 1document.body; 返回html元素对象 1document.documentElement; 事件基础事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发— 响应机制。 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。 事件三要素 事件源(谁) 事件类型(什么事件) 事件处理程序(做啥) 123456789101112&lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件是有三部分组成 事件源 事件类型 事件处理程序 我们也称为事件三要素 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById('btn'); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() { alert('点秋香'); }&lt;/script&gt; 事件执行步骤 获取事件源 注册事件(绑定事件) 添加事件处理程序(采取函数赋值形式) 12345678910111213&lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector('div'); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() { console.log('我被选中了'); }&lt;/script&gt; 鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 操作元素JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性 改变元素内容 element.innerText: 从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉(不识别HTML标签) element.innerHTML: 起始位置到终止位置的全部内容，包括HTML标签，同时保留空格和换行(识别HTML标签) 改变元素属性12345678// img.属性img.src = &quot;xxx&quot;;input.value = &quot;xxx&quot;;input.type = &quot;xxx&quot;;input.checked = &quot;xxx&quot;;input.selected = true / false;input.disabled = true / false; 改变样式属性通过 JS 修改元素的大小、颜色、位置等样式。 123// element.stylediv.style.backgroundColor = 'pink';div.style.width = '250px'; 1element.className = 'xxx'; JS里面的样式采取驼峰命名法，比如 fontSize ，backgroundColor JS 修改 style 样式操作 ，产生的是行内样式，CSS权重比较高 如果样式修改较多，可以采取操作类名方式更改元素样式 class 因为是个保留字，因此使用className来操作元素类名属性 className 会直接更改元素的类名，会覆盖原先的类名 排他思想 如果有同一组元素，我们相要某一个元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式（干掉其他人） 给当前元素设置样式 （留下我自己） 注意顺序不能颠倒，首先干掉其他人，再设置自己 12345678910111213141516171819202122232425&lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;script&gt; // 1. 获取所有按钮元素 var btns = document.getElementsByTagName('button'); // btns得到的是伪数组 里面的每一个元素 btns[i] for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { // (1) 我们先把所有的按钮背景颜色去掉 干掉所有人 for (var i = 0; i &lt; btns.length; i++) { btns[i].style.backgroundColor = ''; } // (2) 然后才让当前的元素背景颜色为pink 留下我自己 this.style.backgroundColor = 'pink'; } } //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想 &lt;/script&gt;&lt;/body&gt; 自定义属性获取属性值element.属性：获取内置属性值(元素本身自带的属性) element.getAttribute('属性')：获取自定义属性值 设置属性值element.属性 = '值'：设置内置属性值 element.setAttribute('属性', '值')：设置自定义属性值 移除属性 element.removeAttribute('属性') H5自定义属性H5规定自定义属性 data-开头作为属性名并赋值 123&lt;div data-index = &quot;1&quot;&gt;&lt;/&gt;// 或者使用JavaScript设置div.setAttribute('data-index',1); 获取H5自定义属性 兼容性获取 element.getAttribute('data-index') H5新增的：element.dataset.index 或element.dataset['index'] IE11才开始支持 节点操作获取元素通常使用两种方式： 1.利用DOM提供的方法获取元素 2.利用节点层级关系获取元素 document.getElementById() 利用父子兄节点关系获取元素 document.getElementsByTagName() 逻辑性强，但是兼容性较差 document.querySelector 等 逻辑性不强，繁琐 节点概述网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。 一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 节点类型分为三类：元素节点：nodeType 为1 、属性节点：nodeType 为2 、 文本节点：nodeType 为3(文本节点包括文字、空格、换行等） 我们在实际开发中，节点操作主要操作的是元素节点 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 父级节点 node.parentNode：可以返回某节点的父结点，注意是最近的一个父结点 如果指定的节点没有父结点则返回null 子节点 node.childNodes（标准）：返回包含指定节点的子节点的集合，该集合为即时更新的集合 返回值包含了所有的子结点，包括元素节点，文本节点等 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes node.children： 是一个只读属性，返回所有的子元素节点 它只返回子元素节点，其余节点不返回 （这个是我们重点掌握的） 第一个子节点node.firstChild ：返回第一个子节点，找不到则返回null 包含所有的节点 node.firstElementChild ：返回第一个子元素节点，找不到则返回null 有兼容性问题，IE9以上才支持 最后一个子节点 node.lastChild：返回最后一个子节点，找不到则返回null 包含所有节点 node.lastElementChild ：返回最后一个子元素节点，找不到则返回null 有兼容性问题，IE9以上才支持 考虑兼容性实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 如果想要第一个子元素节点，可以使用 node.chilren[0] 如果想要最后一个子元素节点，可以使用 node.chilren[node.chilren.length - 1] 下一个兄弟节点node.nextSibling ：返回当前元素的下一个兄弟节点，找不到则返回null 包含所有的节点 node.nextElementSibling： 返回当前元素下一个兄弟元素节点，找不到则返回null 有兼容性问题，IE9才支持 上一个兄弟节点node.previousSibling： 返回当前元素上一个兄弟节点，找不到则返回null 包含所有的节点 node.previousElementSibling 返回当前元素上一个兄弟元素节点，找不到则返回null 有兼容性问题，IE9才支持 创建节点document.createElement('tagName')： 创建由 tagName 指定的HTML 元素 因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点 添加节点node.appendChild(child) ：将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。 node.insertBefore(child, 指定元素) ：将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。 删除节点node.removeChild(child)：从 DOM 中删除一个子节点，返回删除的节点 复制节点node.cloneNode()：返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点 如果括号参数为空或者为 false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点 如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点 动态表格案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;body&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; //单元格动态生成 &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //对象数组的测试数据 var datas = [ { name: '卫英络', subject: 'javascript', score: 100 }, { name: '卫英络', subject: 'javascript', score: 100 }, { name: '卫英络', subject: 'javascript', score: 100 }, { name: '卫英络', subject: 'javascript', score: 100 } ] var tbody = document.querySelector('tbody'); for(var i = 0; i &lt; datas.length; i++){ var tr = document.createElement('tr'); tbody.appendChild(tr); for(var k in datas[i]){ var td = document.createElement('td'); td.innerHTML = datas[i][k]; tr.appendChild(td); } var td = document.createElement('td'); td.innerHTML='&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;' tr.appendChild(td); } var as = document.querySelectorAll('a'); for(var i = 0; i &lt; as.length; i++){ as[i].onclick = function(){ tbody.removeChild(this.parentNode.parentNode); } } &lt;/script&gt;&lt;/body&gt; 三种动态创建元素的区别 doucument.write()：是直接将内容写入页面的内容流，但是文档流执行完毕（页面加载完毕），再执行这个方法会导致页面全部重绘 element.innerHTML：是将内容写入某个 DOM 节点，创建多个元素效率更高（不采用直接拼接字符串，提前使用数组存放内容，再一次写入 12345var arr = [];for (var i = 0; i &lt;= 100; i++) { arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;');}inner.innerHTML = arr.join(''); document.createElement()：创建多个元素效率稍低一点点，但是结构更清晰 事件高级注册事件给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：传统方式和方法监听注册方式 传统注册方式： 利用 on 开头的事件 onclick btn.onclick = function() {} 特点：注册事件的唯一性，同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式： w3c 标准推荐方式 addEventListener() 它是一个方法 IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替（不使用） 特点：同一个元素同一个事件可以注册多个监听器，按注册顺序依次执行 事件监听eventTarget.addEventListener(type,listener[,useCapture]) 该方法接收三个参数： type:事件类型字符串，比如click,mouseover,注意这里不要带on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;button&gt;传统注册事件&lt;/button&gt; &lt;button&gt;方法监听注册事件&lt;/button&gt; &lt;button&gt;ie9 attachEvent&lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll('button'); // 1. 传统方式注册事件 btns[0].onclick = function() { alert('hi'); } btns[0].onclick = function() { alert('hao a u'); } // 2.方法监听方式 btns[1].addEventListener('click', function() { alert(22); }) btns[1].addEventListener('click', function() { alert(33); }) // 3. attachEvent ie9以前的版本支持 btns[2].attachEvent('onclick', function() { alert(11); }) &lt;/script&gt;&lt;/body&gt; 删除事件传统删除方式eventTarget.onclick = null; removeEventListener删除事件eventTarget.removeEventListener(type,listener[,useCapture]); 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; var divs = document.querySelectorAll('div'); divs[0].onclick = function() { alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; } // 2.removeEventListener 删除事件 divs[1].addEventListener('click',fn); //里面的fn不需要调用加小括号 //注意这里不能使用匿名函数 function fn(){ alert(22); divs[1].removeEventListener('click',fn); } // 3.IE9 中的删除事件方式 divs[2].attachEvent('onclick',fn1); function fn1() { alert(33); divs[2].detachEvent('onclick',fn1); } &lt;/script&gt;&lt;/body&gt; DOM事件流简介 事件流描述的是从页面中接收事件的顺序 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流 捕获阶段12345678910111213141516&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, true); &lt;/script&gt;&lt;/body&gt; 冒泡阶段123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); son.addEventListener('click', function() { alert('son'); }, false); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, false); document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt;&lt;/body&gt; JS 代码中只能执行捕获或者冒泡其中的一个阶段 onclick 和 attachEvent只能得到冒泡阶段 addEventListener(type,listener[,useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false),表示在事件冒泡阶段调用事件处理程序 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 事件对象 event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面 这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去 当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数） 123456789101112131415&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); ul.addEventListener('click',function(e){ console.log(this); //this是绑定事件的元素 console.log(e.currentTarget); //指定绑定事件的元素，同this console.log(e.target); //事件触发的元素，li }) &lt;/script&gt;&lt;/body&gt; 事件对象属性方法 说明 e.target 返回触发事件的对象 标准 e.srcElement 返回触发事件的对象 非标准 ie6-8使用 e.type 返回事件的类型 比如click mouseover 不带on e.cancelBubble 该属性阻止冒泡，非标准，ie6-8使用 e.returnValue 该属性阻止默认行为 非标准，ie6-8使用 e.preventDefault() 该方法阻止默认行为 标准 比如不让链接跳转 e.stopPropagation() 阻止冒泡 标准 阻止对象默认行为12345678910111213&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;script&gt; var a = document.querySelector('a'); a.addEventListener('click', function(e){ console.log(e.type); e.preventDefault(); }) a.onclick = function(e){ //e.returnValue; //ie678 return false; //没有兼容性问题，只能在传统中用 } &lt;/script&gt; 阻止事件冒泡事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点 e.stopPropagation() 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son'); son.addEventListener('click', function(e) { alert('son'); e.stopPropagation(); // 阻止冒泡 dom 推荐的标准 stopPropagation() e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 }, false); var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, false); document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt;&lt;/body&gt; 事件委托 事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点 1234567891011121314&lt;body&gt; &lt;ul&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { e.target.style.backgroundColor = 'pink'; }) &lt;/script&gt;&lt;/body&gt; 常见的鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 禁止鼠标右键和鼠标选中 contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单 selectstart 禁止鼠标选中 12345678910111213&lt;body&gt; &lt;h1&gt;我是一段不愿意分享的文字&lt;/h1&gt; &lt;script&gt; document.addEventListener('contextmenu', function(e) { e.preventDefault(); // 阻止默认行为 }) document.addEventListener('selectstart', function(e) { e.preventDefault(); }) &lt;/script&gt;&lt;/body&gt; 鼠标事件对象 常用鼠标事件对象 说明 e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标 e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标 e.pageX（重点） 返回鼠标相对于文档页面的X坐标 IE9+ 支持 e.pageY（重点） 返回鼠标相对于文档页面的Y坐标 IE9+ 支持 e.screenX 返回鼠标相对于电脑屏幕的X坐标 e.screenY 返回鼠标相对于电脑屏幕的Y坐标 常用键盘事件 键盘事件 触发条件 onkeyup 某个键盘按键被松开时触发 onkeydown 某个键盘按键被按下时触发 onkeypress 某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl shift 箭头等 三个事件的执行顺序是：keydown - keypress - keyup 键盘对象属性e.keyCode: 返回该键的ASCII值（已弃用） onkeydown和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写","link":"/2022/04/30/JS-DOM%E6%8A%80%E6%9C%AF/"},{"title":"JS 基础总结","text":"基础总结初始JavaScript JavaScript 是一种运行在客户端的脚本语言 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 现在也可以基于 Node.js 技术进行服务器端编程 浏览器执行JS简介浏览器分成两部分：渲染引擎和 JS 引擎 渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit JS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8 JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行 JS的组成JavaScript 包括 ECMAScript、DOM、BOM ECMAScriptECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 DOM文档对象模型文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。 BOM浏览器对象模型浏览器对象模型（Browser Object Model，简称BOM），提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 JS初体验JS引入方式 行内式 1&lt;input type=&quot;button&quot; value=&quot;&quot; onclink=&quot;javascript:alert('Hello World')&quot; /&gt; 可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性)，如： onclink 注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号 内嵌式JS 123&lt;script&gt; alert('Hello World!');&lt;/script&gt; 可以将多行JS代码写到&lt;script&gt;标签中 内嵌 JS 是学习时常用的方式 外部JS 1&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt; 引用外部JS文件的script标签中间不可以写代码 基本语法注释 单行注释 1// 单行注释 多行注释 123/* 多行注释*/ 输入输出语句 方法 说明 归属 alert(msg); 浏览器弹出警示框 浏览器 console.log(msg); 浏览器控制台打印信息（主要给程序员看） 浏览器 prompt(info); 浏览看弹出输入框，用户可以输入 浏览器 变量初始化 var是一个JS关键字，用来声明变量(variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间。 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 1234//声明变量同时赋值为18var age = 18; //同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。var age = 18, address ='火影村',salary = 15000; 特殊情况 情况 说明 结果 var age; console.log(age); 只声明，不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10;console.log(age); 不声明 只赋值 10 命名规范数据类型JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。 JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型 12var x = 6; //x为数字var x = &quot;Bill&quot;; //x为字符串 基本数据类型 简单数据类型 说明 默认值 Number 数字型，包含整型值和浮点型值，如21，0.21 0 Boolean 布尔值类型，如true，false ，等价于1和0 false Undefined var a; 声明了变量a但是没有赋值，此时a=undefined undefined（未定义的） string 字符串类型，如“张三” “” Null var a = null; 声明了变量a为空值 null 数字型Number12var age = 12; //整数var Age = 21.3747; //小数 在JS中八进制前面加0，十六进制前面加 0x 数字型范围 最大值：Number.MAX_VALUE 最小值：Number.MIN_VALUE 三个特殊值 Infinity：无穷大 -Infinity：无穷小 NaN：Not a Number ,代表任何一个非数值 isNaN()：方法用来判断非数字，并且返回一个值，如果是数字返回的是false，如果不是数字返回的是true 123456var userAge = 21;var isOk = isNan(userAge);console.log(isOk); //false,21不是一个非数字var userName = &quot;andy&quot;;console.log(isNan(userName)); //true,&quot;andy&quot;是一个非数字 字符串型string12var strMsg = &quot;我爱北京天安门&quot;; //使用双引号表示字符串var strMsg = '我爱北京'; //使用单引号表示字符串 字符串引号嵌套 12var strMsg ='我是一个&quot;高富帅&quot;' //可以用 ' ' 包含 &quot; &quot;var strMsg2 =&quot;我是'高富帅'&quot; //可以用&quot; &quot; 包含 '' 字符串转义符 字符串长度：通过length属性获取 12var strMsg = &quot;我是高富帅！&quot;;alert(strMsg.length); //显示6 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 布尔型Boolean 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12var flag = true;console.log(flag + 1); // 2 true当加法来看当1来看，flase当0来看 未定义undefined 一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果 123456// 如果一个变量声明未赋值，就是undefined 未定义数据类型var str;console.log(str); //undefinedvar variable = undefined;console.log(variable + 'Pink'); //undefinedPink undefined 和 字符串 相加，会拼接字符串console.log(variable + 18); //NaN undefined 和 数字相加，最后结果是NaN 空值 一个声明变量给 null 值，里面存的值为空 123var space = null;console.log(space + 'pink'); //nullpinkconsole.llog(space + 1); // 1 typeof typeof 可用来获取检测变量的数据类型, 空值结果为object 数据类型转换使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。 转换为字符串型 方式 说明 案例 toString() 转成字符串 var num = 1; alert(num.toString()); String()强制转换 转成字符串 var num = 1; alert(String(num)); 加号拼接字符串 和字符串拼接的结果都是字符串 var num =1; alert(num+“我是字符串”); 转换为数字型 方式 说明 案例 parselnt(string)函数 将string类型转成整数数值型 parselnt(‘78’) parseFloat(string)函数 将string类型转成浮点数数值型 parseFloat(‘78.21’) Number()强制转换函数 将string类型转换为数值型 Number(‘12’) js 隐式转换**( - * / ) ** 利用算术运算隐式转换为数值型 ‘12’-0 转换为布尔型 方法 说明 案例 Boolean()函数 其他类型转成布尔值 Boolean(‘true’); 代表空，否定的值会被转换为false，如 ’ ’ , 0, NaN , null , undefined 其余的值都会被被转换为true 运算符运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号 算数运算符1+ - * / % 浮点数精度问题： 浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数 12var result = 0.1 +0.2; //结果不是0.3，0.30000000000000004console.log(0.07 * 100); //结果不是7，而是7.000000000000001 递增和递减运算符比较运算符 运算符名称 说明 案例 结果 &lt; 小于号 1 &lt; 2 true &gt; 大于号 1 &gt; 2 false &gt;= 大于等于号(大于或者等于) 2 &gt;= 2 true &lt;= 小于等于号(小于或者等于) 3 &lt;= 2 false == 判等号(会隐式转型) 37 == 37 true != 不等号 37 != 37 false === 全等 要求值和数据类型都一致 37 === ‘37’ false 逻辑运算符&amp;&amp; || ！ 赋值运算符= += -= *= /= %= 流程控制分支，循环 数组创建数组 利用new创建数组 1var arr = new Array(); //创建一个新的空数组 数组字面量创建 123456// 1.利用数组字面量方式创建空的数组 var 数组名 = [];// 2.使用数组字面量方式创建带初始值的数组var 数组名 = ['小白','小黑','小黄','瑞奇'];// 3.数组中可以存放任意类型的数据，例如字符串，数字，布尔值等var arrStus = ['小白', 12, true, 28.9]; 数组索引（下标）遍历数组for循环 数组长度12var arrStus = [1,2,3];alert(arrStus.length); // 3 数组中新增元素 通过修改length长度新增数组元素 可以通过修改 length 长度来实现数组扩容的目的 123456var arr = ['red', 'green', 'blue', 'pink'];arr.length = 7;console.log(arr);console.log(arr[4]);console.log(arr[5]);console.log(arr[6]); //其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 undefined length 属性是可读写的 通过修改数组索引新增数组元素 可以通过修改数组索引的方式追加数组元素 123var arr = ['red', 'green', 'blue', 'pink'];arr[4] = 'hotpink';console.log(arr); 函数函数声明 利用函数关键字function自定义函数 123456//声明函数function fn(){ //函数体代码}// 调用 可以写在函数声明前面fn(); 函数表达式声明 1234// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...};// 调用的方式，函数调用必须写到函数体下面fn(); 调用函数12//调用函数函数名(); //通过调用函数名来执行函数体代码 函数的参数12345678// 声明函数function getSum(num1,num2){ console.log(num1+num2)}// 调用函数getSum(1,3) //4getSum(6，5) //11 形参和实参个数不匹配 参数个数 说明 实参个数等于形参个数 输出正确结果 实参个数多于形参个数 只取到形参的个数 实参个数小于形参个数 多的形参定义为undefined，结果为NaN 123456789function sum(num1, num2) { console.log(num1 + num2);}sum(100, 200); // 300，形参和实参个数相等，输出正确结果sum(100, 400, 500, 700); // 500，实参个数多于形参，只取到形参的个数sum(200); // 实参个数少于形参，多的形参定义为undefined，结果为NaN 函数的返回值 如果函数没有return，返回的值是undefined 函数只能返回一个值，如果用逗号隔开多个值，以最后一个为准 arguments的使用当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。 arguments展示形式是一个伪数组，因此可以进行遍历 具有length属性 可以按索引存储数据 不具有数组的push，pop等方法 作用域JavaScript (ES6前) 中的作用域有两种： 全局作用域 局部作用域(函数作用域) 全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件 局部（函数）作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域 JS没有块级作用域(在ES6之前) 12345if(true){ int num = 123; System.out.println(num); // 123}System.out.println(num); // 123 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种：全局变量和局部变量 全局变量在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量） 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量 局部变量 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 作用域链1234567891011// 作用域链: 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链表var num = 10;funtion fn() { //外部函数 var num = 20; function fun() { //内部函数 console.log(num); // 20 ,一级一级访问 }}//作用域链：采取就近原则的方式来查找变量最终的值。 预解析JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行 预解析：js引擎会把js里面所有的 var 还有 function 提升到当前作用域的最前面 代码执行：从上到下执行JS语句 变量预解析变量预解析也叫做变量提升 变量提升: 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升 12345678console.log(num); // 结果是多少？var num = 10; // undefined//相当于执行了以下代码var num; // 变量声明提升到当前作用域最上面console.log(num);num = 10; // 变量的赋值不会提升 函数预解析函数预解析也叫做函数提升 函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数 匿名函数(函数表达式方式): 函数调用必须写在函数声明的下面 123456789101112// 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面fn();var fn = function() { console.log('22'); // 报错}//相当于执行了以下代码var fn;fn(); //fn没赋值，没这个，报错var fn = function() { console.log('22'); //报错} 对象在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等 创建对象利用字面量创建对象对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法 { } 里面采取键值对的形式表示 12345678910var star = { name : 'pink', age : 18, sex : '男', sayHi : function(){ alert('大家好啊~'); }};// 多个属性或者方法中间用逗号隔开// 方法冒号后面跟的是一个匿名函数 对象调用 属性调用：1.对象.属性名 2.对象[‘属性名’] 函数调用：对象.方法名() 123console.log(star.name) // 调用名字属性console.log(star['name']) // 调用名字属性star.sayHi(); // 调用 sayHi 方法,注意，一定不要忘记带后面的括号 利用new Object创建对象创建方式：var 对象名 = new Object(); 使用格式：对象.属性 = 值 1234567891011var obj = new Object(); //创建了一个空的对象obj.name = '张三丰';obj.age = 18;obj.sex = '男';obj.sayHi = function() { console.log('hi~');}console.log(obj.name);console.log(obj['sex']);obj.sayHi(); 利用构造函数创建对象构造函数 ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。 1234567//构造函数的语法格式function 构造函数名() { this.属性 = 值; this.方法 = function() {}}new 构造函数名(); 1234567891011121314151617181920212223//1. 构造函数名字首字母要大写//2. 构造函数不需要return就可以返回结果//3. 调用构造函数必须使用 new//4. 我们只要new Star() 调用函数就创建了一个对象//5. 我们的属性和方法前面必须加thisfunction Star(uname,age,sex) { this.name = uname; this.age = age; this.sex = sex; this.sing = function(sang){ console.log(sang); }}var ldh = new Star('刘德华',18,'男');console.log(typeof ldh) // object对象，调用函数返回的是对象console.log(ldh.name);console.log(ldh['sex']);ldh.sing('冰雨');//把冰雨传给了sangvar zxy = new Star('张学友',19,'男'); 构造函数名字首字母要大写 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 遍历对象的属性 for...in 语句用于对数组或者对象的属性进行循环操作 12345for(var k in obj) { console.log(k); //这里的 k 是属性名 console.log(obj[k]);//这里的 obj[k] 是属性值} 内置对象 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象 JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 Math对象Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 1234567891011121314151617Math.PI // 圆周率Math.floor() // 向下取整Math.ceil() // 向上取整Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值 Math.random() // 随机返回一个小数，取值为[0，1),console.log(Math.PI); console.log(Math.max(1,99,3)); // 99// 得到两个数之间的随机整数，并且包含这两个整数function getRandom(min,max) { return Math.floor(Math.random() * (max - min + 1)) + min;}console.log(getRandom(1,10)); Date()日期对象 Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用 Date 实例用来处理日期和时间 Date()方法的使用12345678910var now = new Date(); //首先要实例化，没有参数则返回当前系统的时间console.log(now);// 2.参数常用的写法 数字型 2019,10,1 字符串型 '2019-10-1 8:8:8' 时分秒// 如果Date()里面写参数，就返回括号里面输入的时间 var data = new Date(2019,10,1);console.log(data); // 返回的是11月不是10月var data2 = new Date('2019-10-1 8:8:8');console.log(data2); 日期格式化 方法名 说明 getFullYear() 获取当年 getMonth() 获取当月**(0-11)** getDate() 获取当天日期 getDay() 获取星期几**(周日0到周六6)** getHours() 获取当前小时 getMinutes() 获取当前小时 getSeconds() 获取当前秒钟 valueOf() 得到现在时间距离1970.1.1总的毫秒数 getTime() 得到现在时间距离1970.1.1总的毫秒数 获取日期总的毫秒形式12345678910111213141516// 获取Date总的毫秒数 不是当前时间的毫秒数 而是距离1970年1月1号过了多少毫秒数// 实例化Date对象var date = new Date();// 1 .通过 valueOf() getTime() 用于获取对象的原始值console.log(date.valueOf()); //得到现在时间距离1970.1.1总的毫秒数console.log(date.getTime());// 2.简单的写法var date1 = +new Date(); // +new Date()返回的就是总的毫秒数，console.log(date1);// 3. HTML5中提供的方法 获得总的毫秒数 有兼容性问题console.log(Date.now()); 倒计时效果 123456789101112131415function() countDown(time){ var nowTime = +new Date(); //没有参数，返回的是当前时间总的毫秒数 var inputTime = +new Date(time); // 有参数，返回的是用户输入时间的总毫秒数 var times = (inputTime - nowTime) / 1000 //剩余时间的总的秒数 var d = parseInt(times / 60 / 60 / 24); //天数 d &lt; 10 ? '0' + d : d; var h = parseInt(times / 60 / 60 % 24); //小时 h &lt; 10 ? '0' + h : h; var m = parseInt(times / 60 % 60); //分 m &lt; 10 ? '0' + m : m; var s = parseInt(times % 60); //秒 s &lt; 10 ? '0' + s : s; return d + '天' + h + '时' + m + '分' + s + '秒';} 数组对象创建方式12var arr1 = [1, 2, 3]; //1.字面量方式var arr2 = new Array(2, 3); //2.new Array() 检测是否为数组 instanceof 运算符，可以判断一个对象是否属于某种类型 Array.isArray() 用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 123456var arr = [1, 23];var obj = {};console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // falseconsole.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素 方法名 说明 返回值 push(参数1…) 末尾添加一个或多个元素，会修改原数组 并返回新的长度 pop() 删除数组最后一个元素 返回它删除的元素的值 unshift(参数1…) 向数组的开头添加一个或更多元素，注意修改原数组 并返回新的长度 shift() 删除数组的第一个元素，数组长度减1，无参数，修改原数组 并返回第一个元素 数组排序 方法名 说明 是否修改原数组 reverse() 颠倒数组中元素的顺序，无参数 该方法会改变原来的数组，返回新数组 sort() 对数组的元素进行排序 该方法会改变原来的数组，返回新数组 1234567var arr = [1,64,9,61];arr.sort( function(a,b) { return b - a; //降序的排列 return a - b; //升序 }) 查找元素索引 方法名 说明 返回值 indexOf() 数组中查找给定元素的第一个索引 如果存在返回索引号，如果不存在，则返回-1 lastIndexOf() 在数组的最后一个索引，从后向前索引 如果存在返回索引号，如果不存在，则返回-1 数组转换为字符串 方法名 说明 返回值 toString() 把数组转换成字符串，逗号分隔每一项 返回一个字符串 join(‘分隔符’) 方法用于把数组中的所有元素转换为一个字符串 返回一个字符串 12345678// 1.toString() 将我们的数组转换为字符串var arr = [1, 2, 3];console.log(arr.toString()); // 1,2,3// 2.join('分隔符')var arr1 = ['green', 'blue', 'red'];console.log(arr1.join()); // 不写默认用逗号分割console.log(arr1.join('-')); // green-blue-redconsole.log(arr1.join('&amp;')); // green&amp;blue&amp;red 其他方法 方法名 说明 返回值 concat() 连接两个或多个数组 不影响原数组 返回一个新的数组 slice() 数组截取slice(begin,end) 返回被截取项目的新数组 splice() 数组删除splice(第几个开始要删除的个数) 返回被删除项目的新数组，这个会影响原数组 字符串对象基本包装类型为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 12var str = 'andy';console.log(str.length); 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1.生成临时变量,把简单类型包装为复杂数据类型var temp = new String('andy');// 2.赋值给我们声明的字符变量str = temp;// 3.销毁临时变量temp = null; 字符串不可变：指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 返回字符索引字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 方法名 说明 indexOf(‘要查找的字符’，开始的位置) 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号 lastIndexOf() 从后往前找，只找第一个匹配的 返回索引字符 charAt(index) 返回指定位置的字符(index字符串的索引号) str.charAt(0) charCodeAt(index) 获取指定位置处字符的ASCII码(index索引号) str.charCodeAt(0) str[index] 获取指定位置处字符 HTML,IE8+支持和charAt()等效 字符串操作方法 方法名 说明 concat(str1,str2,str3…) concat() 方法用于连接两个或对各字符串。拼接字符串 substr(start,length) 从 start 位置开始(索引号), length 取的个数。 slice(start,end) 从 start 位置开始，截取到 end 位置 ，end 取不到 (两个都是索引号) substring(start,end) 从 start 位置开始，截取到 end 位置 ，end 取不到 (基本和 slice 相同，但是不接受负) 其他方法 方法名 说明 replace(‘a’, ‘b’) 用于在字符串中用一些字符替换另一些字符 split() 用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组 toUpperCase() 转换大写 toLowerCase() 转换小写 123var str = 'a,b,c,d';console.log(str.split(','));// 返回的是一个数组 ['a', 'b', 'c', 'd']","link":"/2022/04/30/JS-%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"AI算法","slug":"AI算法","link":"/tags/AI%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"项目实践","slug":"项目实践","link":"/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}